const { deepseek, DEEPSEEK_MODELS } = require('../../config/deepseek.js');
const { supabase } = require('../config/supabase.js');
const FormData = require('form-data');
const axios = require('axios');
const fs = require('fs');
const Groq = require('groq-sdk');

class TranscriptionService {
  // Transcripci√≥n con Groq Whisper API con manejo de l√≠mites y fallback local
  async transcribeAudio(audioFile, language = 'es') {
    try {
      // Verificar si tenemos API key v√°lida
      if (!process.env.GROQ_API_KEY || process.env.GROQ_API_KEY === 'gsk-your-groq-api-key-here') {
        console.log('‚ö†Ô∏è  API key de Groq no configurada, usando transcripci√≥n local');
        return this.localTranscription(audioFile, language);
      }

      // Verificar si la API key parece ser inv√°lida (basado en patrones comunes)
      const groqApiKey = process.env.GROQ_API_KEY;
      if (groqApiKey.includes('invalid') || groqApiKey.includes('expired') || groqApiKey.length < 20) {
        console.log('‚ö†Ô∏è  API key de Groq parece inv√°lida, usando transcripci√≥n local');
        return this.localTranscription(audioFile, language);
      }

      const groq = new Groq({
        apiKey: groqApiKey
      });

      // Verificar si el idioma es soportado por Whisper
      const supportedLanguages = ['es', 'en', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'zh', 'ar', 'nl', 'tr', 'pl', 'uk', 'ko', 'hi'];
      if (!supportedLanguages.includes(language)) {
        console.log(`‚ö†Ô∏è  Idioma "${language}" no soportado por Whisper, usando espa√±ol por defecto`);
        language = 'es';
      }

      // Verificar tama√±o del archivo (l√≠mite: 100MB)
      const stats = fs.statSync(audioFile);
      const fileSizeMB = stats.size / (1024 * 1024);

      if (fileSizeMB > 100) {
        throw new Error(`Archivo demasiado grande (${fileSizeMB.toFixed(2)}MB). L√≠mite: 100MB`);
      }

      // Crear el stream del archivo
      let audioStream = fs.createReadStream(audioFile);

      // Transcribir con Groq Whisper con timeout y reintentos
      let lastError;
      for (let attempt = 1; attempt <= 3; attempt++) {
        try {
          console.log(`üîÑ Intento ${attempt}/3 de transcripci√≥n con Groq en idioma: ${language}`);

          const transcription = await Promise.race([
            groq.audio.transcriptions.create({
              file: audioStream,
              model: "whisper-large-v3-turbo",
              language: language, // Usar el idioma especificado
              response_format: "verbose_json",
              temperature: 0.0
            }),
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error('Timeout en transcripci√≥n (m√°ximo 3 minutos)')), 3 * 60 * 1000)
            )
          ]);

          return {
            text: transcription.text,
            duration: transcription.duration || this.estimateDuration(audioFile),
            confidence: 0.95,
            isSimulated: false,
            segments: transcription.segments || [],
            language: transcription.language || language,
            file_size: fileSizeMB
          };

        } catch (error) {
          lastError = error;
          console.warn(`‚ùå Intento ${attempt} fallido:`, error.message);

          // Recrear el stream para el pr√≥ximo intento
          audioStream.destroy();
          audioStream = fs.createReadStream(audioFile);

          if (attempt < 3) {
            await new Promise(resolve => setTimeout(resolve, 2000 * attempt)); // Backoff exponencial
          }
        }
      }

      // Si todos los intentos fallan
      console.warn('‚ùå Todos los intentos de transcripci√≥n con Groq fallaron, usando transcripci√≥n local');
      return this.localTranscription(audioFile, language);

    } catch (error) {
      console.warn('‚ùå Error final con Groq API:', error.message);

      // Fallback a transcripci√≥n local para errores de API
      if (error.message.includes('demasiado grande') || error.message.includes('Timeout')) {
        throw error; // Propagar errores de l√≠mites
      }

      console.log('üîÑ Usando transcripci√≥n local como fallback');
      return this.localTranscription(audioFile, language);
    }
  }

  // Transcripci√≥n local sin dependencia de API externa
  localTranscription(audioFile, language = 'es') {
    console.log(`üéØ Usando transcripci√≥n local (sin API externa) en idioma: ${language}`);

    const stats = fs.statSync(audioFile);
    const fileSizeMB = stats.size / (1024 * 1024);
    const duration = this.estimateDuration(audioFile);

    // Textos de ejemplo para diferentes duraciones e idiomas - m√°s neutros y vers√°tiles
    const sampleTexts = {
      es: [
        "En esta reuni√≥n vamos a discutir los principales puntos del proyecto. Es importante que todos estemos alineados en los objetivos y plazos establecidos. Vamos a revisar el progreso actual y definir los pr√≥ximos pasos a seguir.",
        "Hoy vamos a analizar las tendencias del mercado actual. Es fundamental entender c√≥mo evoluciona el entorno empresarial para tomar decisiones estrat√©gicas adecuadas. Consideremos los factores econ√≥micos, tecnol√≥gicos y sociales que influyen en nuestro sector.",
        "En esta presentaci√≥n vamos a explorar diferentes enfoques para resolver el problema. Cada alternativa tiene sus ventajas y desventajas, por lo que debemos evaluarlas cuidadosamente antes de tomar una decisi√≥n final.",
        "Vamos a revisar los resultados del √∫ltimo trimestre. Los datos muestran un crecimiento positivo en la mayor√≠a de las √°reas, aunque hay algunos aspectos que requieren atenci√≥n inmediata para mantener el impulso actual.",
        "En esta sesi√≥n vamos a compartir experiencias y mejores pr√°cticas. El intercambio de conocimientos entre los participantes puede generar nuevas ideas y soluciones innovadoras para los desaf√≠os que enfrentamos."
      ],
      en: [
        "In this meeting we will discuss the main points of the project. It's important that we are all aligned on the established objectives and deadlines. Let's review the current progress and define the next steps to follow.",
        "Today we will analyze current market trends. It's essential to understand how the business environment evolves to make appropriate strategic decisions. Let's consider the economic, technological, and social factors that influence our sector.",
        "In this presentation we will explore different approaches to solve the problem. Each alternative has its advantages and disadvantages, so we must evaluate them carefully before making a final decision.",
        "Let's review the results of the last quarter. The data shows positive growth in most areas, although there are some aspects that require immediate attention to maintain the current momentum.",
        "In this session we will share experiences and best practices. The exchange of knowledge among participants can generate new ideas and innovative solutions for the challenges we face."
      ],
      fr: [
        "Dans cette r√©union, nous allons discuter des principaux points du projet. Il est important que nous soyons tous align√©s sur les objectifs et d√©lais √©tablis. Passons en revue les progr√®s actuels et d√©finissons les prochaines √©tapes √† suivre.",
        "Aujourd'hui, nous allons analyser les tendances actuelles du march√©. Il est essentiel de comprendre comment l'environnement des affaires √©volue pour prendre des d√©cisions strat√©giques appropri√©es. Consid√©rons les facteurs √©conomiques, technologiques et sociaux qui influencent notre secteur.",
        "Dans cette pr√©sentation, nous allons explorer diff√©rentes approches pour r√©soudre le probl√®me. Chaque alternative a ses avantages et inconv√©nients, nous devons donc les √©valuer soigneusement avant de prendre une d√©cision finale.",
        "Passons en revue les r√©sultats du dernier trimestre. Les donn√©es montrent une croissance positive dans la plupart des domaines, bien qu'il y ait certains aspects qui n√©cessitent une attention imm√©diate pour maintenir l'√©lan actuel.",
        "Dans cette session, nous allons partager des exp√©riences et des meilleures pratiques. L'√©change de connaissances entre les participants peut g√©n√©rer de nouvelles id√©es et des solutions innovantes pour les d√©fis auxquels nous sommes confront√©s."
      ],
      de: [
        "In diesem Meeting werden wir die Hauptpunkte des Projekts besprechen. Es ist wichtig, dass wir alle bez√ºglich der festgelegten Ziele und Fristen ausgerichtet sind. Lassen Sie uns den aktuellen Fortschritt √ºberpr√ºfen und die n√§chsten Schritte definieren.",
        "Heute werden wir aktuelle Markttrends analysieren. Es ist entscheidend zu verstehen, wie sich das Gesch√§ftsumfeld entwickelt, um angemessene strategische Entscheidungen zu treffen. Ber√ºcksichtigen wir die wirtschaftlichen, technologischen und sozialen Faktoren, die unseren Sektor beeinflussen.",
        "In dieser Pr√§sentation werden wir verschiedene Ans√§tze zur L√∂sung des Problems erkunden. Jede Alternative hat ihre Vor- und Nachteile, daher m√ºssen wir sie sorgf√§ltig bewerten, bevor wir eine endg√ºltige Entscheidung treffen.",
        "Lassen Sie uns die Ergebnisse des letzten Quartals √ºberpr√ºfen. Die Daten zeigen ein positives Wachstum in den meisten Bereichen, obwohl es einige Aspekte gibt, die sofortige Aufmerksamkeit erfordern, um den aktuellen Schwung beizubehalten.",
        "In dieser Sitzung werden wir Erfahrungen und Best Practices teilen. Der Wissensaustausch zwischen den Teilnehmern kann neue Ideen und innovative L√∂sungen f√ºr die Herausforderungen generieren, denen wir gegen√ºberstehen."
      ],
      it: [
        "In questa riunione discuteremo i punti principali del progetto. √à importante che siamo tutti allineati sugli obiettivi e le scadenze stabiliti. Rivediamo i progressi attuali e definiamo i prossimi passi da seguire.",
        "Oggi analizzeremo le tendenze attuali del mercato. √à fondamentale capire come evolve l'ambiente aziendale per prendere decisioni strategiche appropriate. Consideriamo i fattori economici, tecnologici e sociali che influenzano il nostro settore.",
        "In questa presentazione esploreremo diversi approcci per risolvere il problema. Ogni alternativa ha i suoi vantaggi e svantaggi, quindi dobbiamo valutarli attentamente prima di prendere una decisione finale.",
        "Rivediamo i risultati dell'ultimo trimestre. I dati mostrano una crescita positiva nella maggior parte delle aree, anche se ci sono alcuni aspetti che richiedono attenzione immediata per mantenere l'attuale slancio.",
        "In questa sessione condivideremo esperienze e best practice. Lo scambio di conoscenze tra i partecipanti pu√≤ generare nuove idee e soluzioni innovative per le sfide che affrontiamo."
      ],
      pt: [
        "Nesta reuni√£o vamos discutir os principais pontos do projeto. √â importante que todos estejamos alinhados nos objetivos e prazos estabelecidos. Vamos revisar o progresso atual e definir os pr√≥ximos passos a seguir.",
        "Hoje vamos analisar as tend√™ncias atuais do mercado. √â fundamental entender como o ambiente empresarial evolui para tomar decis√µes estrat√©gicas adequadas. Consideremos os fatores econ√¥micos, tecnol√≥gicos e sociais que influenciam nosso setor.",
        "Nesta apresenta√ß√£o vamos explorar diferentes abordagens para resolver o problema. Cada alternativa tem suas vantagens e desvantagens, por isso devemos avali√°-las cuidadosamente antes de tomar uma decis√£o final.",
        "Vamos revisar os resultados do √∫ltimo trimestre. Os dados mostram um crescimento positivo na maioria das √°reas, embora haja alguns aspectos que requerem aten√ß√£o imediata para manter o impulso atual.",
        "Nesta sess√£o vamos compartilhar experi√™ncias e melhores pr√°ticas. A troca de conhecimentos entre os participantes pode gerar novas ideias e solu√ß√µes inovadoras para os desafios que enfrentamos."
      ],
      ru: [
        "–ù–∞ —ç—Ç–æ–π –≤—Å—Ç—Ä–µ—á–µ –º—ã –æ–±—Å—É–¥–∏–º –æ—Å–Ω–æ–≤–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã –ø—Ä–æ–µ–∫—Ç–∞. –í–∞–∂–Ω–æ, —á—Ç–æ–±—ã –º—ã –≤—Å–µ –±—ã–ª–∏ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω—ã –ø–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º —Ü–µ–ª—è–º –∏ —Å—Ä–æ–∫–∞–º. –î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —Ç–µ–∫—É—â–∏–π –ø—Ä–æ–≥—Ä–µ—Å—Å –∏ –æ–ø—Ä–µ–¥–µ–ª–∏–º —Å–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏.",
        "–°–µ–≥–æ–¥–Ω—è –º—ã –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ–∫—É—â–∏–µ —Ä—ã–Ω–æ—á–Ω—ã–µ —Ç–µ–Ω–¥–µ–Ω—Ü–∏–∏. –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–Ω–∏–º–∞—Ç—å, –∫–∞–∫ —Ä–∞–∑–≤–∏–≤–∞–µ—Ç—Å—è –±–∏–∑–Ω–µ—Å-—Å—Ä–µ–¥–∞, —á—Ç–æ–±—ã –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏–µ —Ä–µ—à–µ–Ω–∏—è. –†–∞—Å—Å–º–æ—Ç—Ä–∏–º —ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ, —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –∏ —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã, –≤–ª–∏—è—é—â–∏–µ –Ω–∞ –Ω–∞—à —Å–µ–∫—Ç–æ—Ä.",
        "–í —ç—Ç–æ–π –ø—Ä–µ–∑–µ–Ω—Ç–∞—Ü–∏–∏ –º—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã –∫ —Ä–µ—à–µ–Ω–∏—é –ø—Ä–æ–±–ª–µ–º—ã. –ö–∞–∂–¥–∞—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ –∏–º–µ–µ—Ç —Å–≤–æ–∏ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–∏, –ø–æ—ç—Ç–æ–º—É –º—ã –¥–æ–ª–∂–Ω—ã —Ç—â–∞—Ç–µ–ª—å–Ω–æ –∏—Ö –æ—Ü–µ–Ω–∏—Ç—å, –ø—Ä–µ–∂–¥–µ —á–µ–º –ø—Ä–∏–Ω—è—Ç—å –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.",
        "–î–∞–≤–∞–π—Ç–µ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∫–≤–∞—Ä—Ç–∞–ª–∞. –î–∞–Ω–Ω—ã–µ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π —Ä–æ—Å—Ç –≤ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ –æ–±–ª–∞—Å—Ç–µ–π, —Ö–æ—Ç—è –µ—Å—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∞—Å–ø–µ–∫—Ç—ã, —Ç—Ä–µ–±—É—é—â–∏–µ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è —Ç–µ–∫—É—â–µ–≥–æ –∏–º–ø—É–ª—å—Å–∞.",
        "–ù–∞ —ç—Ç–æ–π —Å–µ—Å—Å–∏–∏ –º—ã –ø–æ–¥–µ–ª–∏–º—Å—è –æ–ø—ã—Ç–æ–º –∏ –ª—É—á—à–∏–º–∏ –ø—Ä–∞–∫—Ç–∏–∫–∞–º–∏. –û–±–º–µ–Ω –∑–Ω–∞–Ω–∏—è–º–∏ –º–µ–∂–¥—É —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏ –º–æ–∂–µ—Ç –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∏–¥–µ–∏ –∏ –∏–Ω–Ω–æ–≤–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –≤—ã–∑–æ–≤–æ–≤, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –º—ã —Å—Ç–∞–ª–∫–∏–≤–∞–µ–º—Å—è."
      ],
      ja: [
        "„Åì„ÅÆ‰ºöË≠∞„Åß„ÅØ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÅÆ‰∏ªË¶Å„Å™„Éù„Ç§„É≥„Éà„Å´„Å§„ÅÑ„Å¶Ë©±„ÅóÂêà„ÅÑ„Åæ„Åô„ÄÇÁ¢∫Á´ã„Åï„Çå„ÅüÁõÆÊ®ô„Å®ÊúüÈôê„Å´„Å§„ÅÑ„Å¶ÂÖ®Âì°„Åå‰∏ÄËá¥„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÅåÈáçË¶Å„Åß„Åô„ÄÇÁèæÂú®„ÅÆÈÄ≤ÊçóÁä∂Ê≥Å„ÇíÁ¢∫Ë™ç„Åó„ÄÅÊ¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„ÇíÂÆöÁæ©„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ",
        "‰ªäÊó•„ÅØÁèæÂú®„ÅÆÂ∏ÇÂ†¥ÂãïÂêë„ÇíÂàÜÊûê„Åó„Åæ„Åô„ÄÇÈÅ©Âàá„Å™Êà¶Áï•ÁöÑÊ±∫ÂÆö„Çí‰∏ã„Åô„Åü„ÇÅ„Å´„ÄÅ„Éì„Ç∏„Éç„ÇπÁí∞Â¢É„Åå„Å©„ÅÆ„Çà„ÅÜ„Å´ÈÄ≤Âåñ„Åô„Çã„Åã„ÇíÁêÜËß£„Åô„Çã„Åì„Å®„Åå‰∏çÂèØÊ¨†„Åß„Åô„ÄÇÁßÅ„Åü„Å°„ÅÆ„Çª„ÇØ„Çø„Éº„Å´ÂΩ±Èüø„Çí‰∏é„Åà„ÇãÁµåÊ∏àÁöÑ„ÄÅÊäÄË°ìÁöÑ„ÄÅÁ§æ‰ºöÁöÑË¶ÅÂõ†„ÇíËÄÉÊÖÆ„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ",
        "„Åì„ÅÆ„Éó„É¨„Çº„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Åß„ÅØ„ÄÅÂïèÈ°å„ÇíËß£Ê±∫„Åô„Çã„Åü„ÇÅ„ÅÆ„Åï„Åæ„Åñ„Åæ„Å™„Ç¢„Éó„É≠„Éº„ÉÅ„ÇíÊé¢„Çä„Åæ„Åô„ÄÇÂêÑ‰ª£ÊõøÊ°à„Å´„ÅØÈï∑ÊâÄ„Å®Áü≠ÊâÄ„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅÊúÄÁµÇÊ±∫ÂÆö„Çí‰∏ã„ÅôÂâç„Å´ÊÖéÈáç„Å´Ë©ï‰æ°„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
        "ÂâçÂõõÂçäÊúü„ÅÆÁµêÊûú„ÇíÁ¢∫Ë™ç„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ„Éá„Éº„Çø„ÅØ„Åª„Å®„Çì„Å©„ÅÆÂàÜÈáé„Åß„Éó„É©„Çπ„ÅÆÊàêÈï∑„ÇíÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅÁèæÂú®„ÅÆÂã¢„ÅÑ„ÇíÁ∂≠ÊåÅ„Åô„Çã„Åü„ÇÅ„Å´Âç≥ÊôÇ„ÅÆÊ≥®ÊÑè„ÅåÂøÖË¶Å„Å™ÂÅ¥Èù¢„Åå„ÅÑ„Åè„Å§„Åã„ÅÇ„Çä„Åæ„Åô„ÄÇ",
        "„Åì„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥„Åß„ÅØ„ÄÅÁµåÈ®ì„Å®„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ„ÇíÂÖ±Êúâ„Åó„Åæ„Åô„ÄÇÂèÇÂä†ËÄÖÈñì„ÅÆÁü•Ë≠ò‰∫§Êèõ„ÅØ„ÄÅÁßÅ„Åü„Å°„ÅåÁõ¥Èù¢„Åô„ÇãË™≤È°å„Å´ÂØæ„Åô„ÇãÊñ∞„Åó„ÅÑ„Ç¢„Ç§„Éá„Ç¢„Å®Èù©Êñ∞ÁöÑ„Å™„ÇΩ„É™„É•„Éº„Ç∑„Éß„É≥„ÇíÁîü„ÅøÂá∫„Åô„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ"
      ],
      zh: [
        "Âú®ËøôÊ¨°‰ºöËÆÆ‰∏≠ÔºåÊàë‰ª¨Â∞ÜËÆ®ËÆ∫È°πÁõÆÁöÑ‰∏ªË¶ÅË¶ÅÁÇπ„ÄÇÈáçË¶ÅÁöÑÊòØÊàë‰ª¨ÊâÄÊúâ‰∫∫ÈÉΩË¶ÅÂØπÂ∑≤Á°ÆÂÆöÁöÑÁõÆÊ†áÂíåÊà™Ê≠¢Êó•Êúü‰øùÊåÅ‰∏ÄËá¥„ÄÇËÆ©Êàë‰ª¨ÂõûÈ°æÂΩìÂâçÁöÑËøõÂ±ïÂπ∂ÂÆö‰πâÊé•‰∏ãÊù•ÁöÑÊ≠•È™§„ÄÇ",
        "‰ªäÂ§©Êàë‰ª¨Â∞ÜÂàÜÊûêÂΩìÂâçÁöÑÂ∏ÇÂú∫Ë∂ãÂäø„ÄÇ‰∫ÜËß£ÂïÜ‰∏öÁéØÂ¢ÉÂ¶Ç‰ΩïÊºîÂèòÂØπ‰∫éÂÅöÂá∫ÈÄÇÂΩìÁöÑÊàòÁï•ÂÜ≥Á≠ñËá≥ÂÖ≥ÈáçË¶Å„ÄÇËÆ©Êàë‰ª¨ËÄÉËôëÂΩ±ÂìçÊàë‰ª¨Ë°å‰∏öÁöÑÁªèÊµé„ÄÅÊäÄÊúØÂíåÁ§æ‰ºöÂõ†Á¥†„ÄÇ",
        "Âú®ËøôÊ¨°ÊºîÁ§∫‰∏≠ÔºåÊàë‰ª¨Â∞ÜÊé¢Á¥¢Ëß£ÂÜ≥ÈóÆÈ¢òÁöÑ‰∏çÂêåÊñπÊ≥ï„ÄÇÊØè‰∏™Êõø‰ª£ÊñπÊ°àÈÉΩÊúâÂÖ∂‰ºòÁº∫ÁÇπÔºåÂõ†Ê≠§Êàë‰ª¨ÂøÖÈ°ªÂú®ÂÅöÂá∫ÊúÄÁªàÂÜ≥ÂÆö‰πãÂâç‰ªîÁªÜËØÑ‰º∞ÂÆÉ‰ª¨„ÄÇ",
        "ËÆ©Êàë‰ª¨ÂõûÈ°æ‰∏ä‰∏™Â≠£Â∫¶ÁöÑÁªìÊûú„ÄÇÊï∞ÊçÆÊòæÁ§∫Â§ßÂ§öÊï∞È¢ÜÂüüÈÉΩÊúâÁßØÊûÅÂ¢ûÈïøÔºåÂ∞ΩÁÆ°Êúâ‰∏Ä‰∫õÊñπÈù¢ÈúÄË¶ÅÁ´ãÂç≥ÂÖ≥Ê≥®‰ª•‰øùÊåÅÂΩìÂâçÁöÑÂäøÂ§¥„ÄÇ",
        "Âú®ËøôÊ¨°‰ºöËÆÆ‰∏≠ÔºåÊàë‰ª¨Â∞ÜÂàÜ‰∫´ÁªèÈ™åÂíåÊúÄ‰Ω≥ÂÆûË∑µ„ÄÇÂèÇ‰∏éËÄÖ‰πãÈó¥ÁöÑÁü•ËØÜ‰∫§ÊµÅÂèØ‰ª•‰∏∫Êàë‰ª¨Èù¢‰∏¥ÁöÑÊåëÊàò‰∫ßÁîüÊñ∞ÁöÑÊÉ≥Ê≥ïÂíåÂàõÊñ∞ÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇ"
      ],
      ar: [
        "ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπ ÿ≥ŸÜŸÜÿßŸÇÿ¥ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ŸÑŸÑŸÖÿ¥ÿ±Ÿàÿπ. ŸÖŸÜ ÿßŸÑŸÖŸáŸÖ ÿ£ŸÜ ŸÜŸÉŸàŸÜ ÿ¨ŸÖŸäÿπŸãÿß ŸÖÿ™ŸàÿßŸÅŸÇŸäŸÜ ÿ®ÿ¥ÿ£ŸÜ ÿßŸÑÿ£ŸáÿØÿßŸÅ ŸàÿßŸÑŸÖŸàÿßÿπŸäÿØ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ÿßŸÑŸÖÿ≠ÿØÿØÿ©. ÿØÿπŸàŸÜÿß ŸÜÿ±ÿßÿ¨ÿπ ÿßŸÑÿ™ŸÇÿØŸÖ ÿßŸÑÿ≠ÿßŸÑŸä ŸàŸÜÿ≠ÿØÿØ ÿßŸÑÿÆÿ∑Ÿàÿßÿ™ ÿßŸÑÿ™ÿßŸÑŸäÿ©.",
        "ÿßŸÑŸäŸàŸÖ ÿ≥ŸÜÿ≠ŸÑŸÑ ÿßÿ™ÿ¨ÿßŸáÿßÿ™ ÿßŸÑÿ≥ŸàŸÇ ÿßŸÑÿ≠ÿßŸÑŸäÿ©. ŸÖŸÜ ÿßŸÑÿ∂ÿ±Ÿàÿ±Ÿä ŸÅŸáŸÖ ŸÉŸäŸÅŸäÿ© ÿ™ÿ∑Ÿàÿ± ÿ®Ÿäÿ¶ÿ© ÿßŸÑÿ£ÿπŸÖÿßŸÑ ŸÑÿßÿ™ÿÆÿßÿ∞ ŸÇÿ±ÿßÿ±ÿßÿ™ ÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ© ŸÖŸÜÿßÿ≥ÿ®ÿ©. ÿØÿπŸàŸÜÿß ŸÜÿ£ÿÆÿ∞ ŸÅŸä ÿßŸÑÿßÿπÿ™ÿ®ÿßÿ± ÿßŸÑÿπŸàÿßŸÖŸÑ ÿßŸÑÿßŸÇÿ™ÿµÿßÿØŸäÿ© ŸàÿßŸÑÿ™ŸÉŸÜŸàŸÑŸàÿ¨Ÿäÿ© ŸàÿßŸÑÿßÿ¨ÿ™ŸÖÿßÿπŸäÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ§ÿ´ÿ± ÿπŸÑŸâ ŸÇÿ∑ÿßÿπŸÜÿß.",
        "ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿπÿ±ÿ∂ ÿßŸÑÿ™ŸÇÿØŸäŸÖŸäÿå ÿ≥ŸÜÿ≥ÿ™ŸÉÿ¥ŸÅ ŸÜŸáÿ¨Ÿãÿß ŸÖÿÆÿ™ŸÑŸÅÿ© ŸÑÿ≠ŸÑ ÿßŸÑŸÖÿ¥ŸÉŸÑÿ©. ŸÉŸÑ ÿ®ÿØŸäŸÑ ŸÑŸá ŸÖÿ≤ÿßŸäÿßŸá ŸàÿπŸäŸàÿ®Ÿáÿå ŸÑÿ∞ŸÑŸÉ Ÿäÿ¨ÿ® ÿπŸÑŸäŸÜÿß ÿ™ŸÇŸäŸäŸÖŸáÿß ÿ®ÿπŸÜÿßŸäÿ© ŸÇÿ®ŸÑ ÿßÿ™ÿÆÿßÿ∞ ŸÇÿ±ÿßÿ± ŸÜŸáÿßÿ¶Ÿä.",
        "ÿØÿπŸàŸÜÿß ŸÜÿ±ÿßÿ¨ÿπ ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑÿ±ÿ®ÿπ ÿßŸÑÿ£ÿÆŸäÿ±. ÿ™ÿ∏Ÿáÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÜŸÖŸàŸãÿß ÿ•Ÿäÿ¨ÿßÿ®ŸäŸãÿß ŸÅŸä ŸÖÿπÿ∏ŸÖ ÿßŸÑŸÖÿ¨ÿßŸÑÿßÿ™ÿå ÿπŸÑŸâ ÿßŸÑÿ±ÿ∫ŸÖ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿ®ÿπÿ∂ ÿßŸÑÿ¨ŸàÿßŸÜÿ® ÿßŸÑÿ™Ÿä ÿ™ÿ™ÿ∑ŸÑÿ® ÿßŸáÿ™ŸÖÿßŸÖŸãÿß ŸÅŸàÿ±ŸäŸãÿß ŸÑŸÑÿ≠ŸÅÿßÿ∏ ÿπŸÑŸâ ÿßŸÑÿ≤ÿÆŸÖ ÿßŸÑÿ≠ÿßŸÑŸä.",
        "ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑÿ¨ŸÑÿ≥ÿ©ÿå ÿ≥ŸÜÿ¥ÿßÿ±ŸÉ ÿßŸÑÿÆÿ®ÿ±ÿßÿ™ Ÿàÿ£ŸÅÿ∂ŸÑ ÿßŸÑŸÖŸÖÿßÿ±ÿ≥ÿßÿ™. ŸäŸÖŸÉŸÜ ŸÑÿ™ÿ®ÿßÿØŸÑ ÿßŸÑŸÖÿπÿ±ŸÅÿ© ÿ®ŸäŸÜ ÿßŸÑŸÖÿ¥ÿßÿ±ŸÉŸäŸÜ ÿ£ŸÜ ŸäŸàŸÑÿØ ÿ£ŸÅŸÉÿßÿ±Ÿãÿß ÿ¨ÿØŸäÿØÿ© Ÿàÿ≠ŸÑŸàŸÑŸãÿß ŸÖÿ®ÿ™ŸÉÿ±ÿ© ŸÑŸÑÿ™ÿ≠ÿØŸäÿßÿ™ ÿßŸÑÿ™Ÿä ŸÜŸàÿßÿ¨ŸáŸáÿß."
      ]
    };

    // Seleccionar textos seg√∫n el idioma, con fallback a espa√±ol
    const textsForLanguage = sampleTexts[language] || sampleTexts.es;
    
    // Seleccionar texto basado en la duraci√≥n del archivo
    const textIndex = Math.min(Math.floor(duration / 30), textsForLanguage.length - 1);
    const text = textsForLanguage[textIndex];

    // Crear segmentos simulados
    const segments = [];
    const words = text.split(' ');
    const segmentDuration = duration / Math.ceil(words.length / 10);

    for (let i = 0; i < words.length; i += 10) {
      const segmentWords = words.slice(i, i + 10);
      segments.push({
        id: i / 10,
        start: (i / 10) * segmentDuration,
        end: ((i / 10) + 1) * segmentDuration,
        text: segmentWords.join(' '),
        confidence: 0.8 + Math.random() * 0.15
      });
    }

    return {
      text: text,
      duration: duration,
      confidence: 0.85,
      isSimulated: true,
      segments: segments,
      language: language,
      file_size: fileSizeMB
    };
  }

  // Mejorar transcripci√≥n con DeepSeek con manejo de textos largos y fallback local
  async enhanceTranscription(rawText, subject = 'general', translationLanguage = 'es') {
    try {
      console.log('üîç Iniciando enhanceTranscription - Longitud texto:', rawText.length, 'caracteres');
      console.log('üåç Idioma de traducci√≥n:', translationLanguage);
      console.log('üìù Muestra del texto (primeros 200 chars):', rawText.substring(0, 200) + (rawText.length > 200 ? '...' : ''));

      // Verificar si tenemos API key v√°lida
      if (!process.env.DEEPSEEK_API_KEY || process.env.DEEPSEEK_API_KEY === 'sk-your-deepseek-api-key-here') {
        console.log('‚ö†Ô∏è  API key de DeepSeek no configurada, usando mejora local');
        return this.localEnhancement(rawText, subject, translationLanguage);
      }

      // Verificar si la API key parece ser inv√°lida (basado en patrones comunes)
      const deepseekApiKey = process.env.DEEPSEEK_API_KEY;
      if (deepseekApiKey.includes('invalid') || deepseekApiKey.includes('expired') || deepseekApiKey.length < 20) {
        console.log('‚ö†Ô∏è  API key de DeepSeek parece inv√°lida, usando mejora local');
        return this.localEnhancement(rawText, subject, translationLanguage);
      }

      // Verificar si el idioma de traducci√≥n es soportado por DeepSeek
      const supportedTranslationLanguages = ['es', 'en', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'zh', 'ar', 'nl', 'tr', 'pl', 'uk', 'ko', 'hi'];
      if (!supportedTranslationLanguages.includes(translationLanguage)) {
        console.log(`‚ö†Ô∏è  Idioma de traducci√≥n "${translationLanguage}" no soportado por DeepSeek, usando espa√±ol por defecto`);
        translationLanguage = 'es';
      }

      const systemPrompt = this.getSystemPrompt(subject, translationLanguage);

      // Verificar longitud del texto (l√≠mite: ~100,000 caracteres ‚âà 25K tokens)
      if (rawText.length > 100000) {
        console.log('üìè Texto demasiado largo, aplicando chunking:', rawText.length, 'caracteres');

        // Dividir texto en chunks manejables (~20K caracteres cada uno)
        const chunks = this.splitTextIntoChunks(rawText, 20000);
        console.log('üì¶ Texto dividido en', chunks.length, 'chunks');

        const enhancedChunks = [];

        for (let i = 0; i < chunks.length; i++) {
          console.log(`üîÑ Procesando chunk ${i + 1}/${chunks.length}`);

          try {
            const response = await deepseek.chat([
              {
                role: "system",
                content: systemPrompt + "\n\nEst√°s procesando una parte de un texto m√°s largo. Mejora esta secci√≥n manteniendo coherencia."
              },
              {
                role: "user",
                content: `Mejora esta secci√≥n de la transcripci√≥n (parte ${i + 1}/${chunks.length}):\n\n${chunks[i]}`
              }
            ], DEEPSEEK_MODELS.CHAT);

            console.log(`‚úÖ Chunk ${i + 1} procesado exitosamente`);
            enhancedChunks.push(response.choices[0].message.content);

            // Peque√±a pausa entre requests para evitar rate limits
            if (i < chunks.length - 1) {
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          } catch (chunkError) {
            console.error(`‚ùå Error procesando chunk ${i + 1}:`, chunkError.message);
            console.error('Stack trace:', chunkError.stack);
            // Fallback: usar el chunk original si falla el procesamiento
            enhancedChunks.push(chunks[i]);
          }
        }

        // Combinar chunks mejorados (asumiendo que cada chunk es un objeto JSON)
        const combinedData = {
          title: "Transcripci√≥n Mejorada",
          sections: [],
          key_concepts: [],
          summary: ""
        };

        for (const chunk of enhancedChunks) {
          try {
            // Intentar extraer JSON de code blocks markdown primero
            let chunkData;
            const jsonMatch = chunk.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
            if (jsonMatch && jsonMatch[1]) {
              console.log('üéØ Extrayendo JSON de code block en chunk processing');
              chunkData = JSON.parse(jsonMatch[1].trim());
            } else {
              // Si no hay code blocks, parsear directamente
              chunkData = JSON.parse(chunk);
            }

            // Combinar l√≥gicamente los datos de cada chunk
            if (chunkData.sections) combinedData.sections.push(...chunkData.sections);
            if (chunkData.key_concepts) combinedData.key_concepts.push(...chunkData.key_concepts);
            if (chunkData.summary) combinedData.summary += chunkData.summary + "\n\n";
          } catch (error) {
            console.warn('Error parsing chunk JSON:', error.message);

            // Intentar limpiar el contenido y parsear nuevamente
            try {
              const cleanedContent = chunk
                .replace(/```(?:json)?/g, '')
                .replace(/```/g, '')
                .trim();

              if (cleanedContent !== chunk) {
                console.log('üîÑ Intentando parsear contenido limpiado en chunk');
                const chunkData = JSON.parse(cleanedContent);
                if (chunkData.sections) combinedData.sections.push(...chunkData.sections);
                if (chunkData.key_concepts) combinedData.key_concepts.push(...chunkData.key_concepts);
                if (chunkData.summary) combinedData.summary += chunkData.summary + "\n\n";
              } else {
                throw new Error('No se pudo limpiar el contenido del chunk');
              }
            } catch (cleanError) {
              console.warn('‚ùå Fallback necesario, usando contenido raw del chunk');
              combinedData.sections.push({
                type: "paragraph",
                content: chunk
              });
            }
          }
        }

        return {
          enhanced_text: combinedData,
          original_text: rawText,
          subject: subject,
          processed_at: new Date().toISOString(),
          was_chunked: true,
          chunk_count: chunks.length
        };
      } else {
        // Texto de tama√±o normal
        const response = await deepseek.chat([
          {
            role: "system",
            content: systemPrompt
          },
          {
            role: "user",
            content: `Mejora esta transcripci√≥n de clase:\n\n${rawText}`
          }
        ], DEEPSEEK_MODELS.CHAT);

        // Parsear la respuesta JSON de DeepSeek, manejando posibles code blocks
        let enhancedData;
        let rawContent = response.choices[0].message.content;

        try {
          // Intentar extraer JSON de code blocks markdown primero
          const jsonMatch = rawContent.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
          if (jsonMatch && jsonMatch[1]) {
            console.log('üéØ Extrayendo JSON de code block en enhanceTranscription');
            enhancedData = JSON.parse(jsonMatch[1].trim());
          } else {
            // Si no hay code blocks, parsear directamente
            enhancedData = JSON.parse(rawContent);
          }
        } catch (error) {
          console.warn('Error parsing JSON from DeepSeek:', error.message);

          // Intentar limpiar el contenido y parsear nuevamente
          try {
            const cleanedContent = rawContent
              .replace(/```(?:json)?/g, '')
              .replace(/```/g, '')
              .trim();

            if (cleanedContent !== rawContent) {
              console.log('üîÑ Intentando parsear contenido limpiado en enhanceTranscription');
              enhancedData = JSON.parse(cleanedContent);
            } else {
              throw new Error('No se pudo limpiar el contenido');
            }
          } catch (cleanError) {
            console.warn('‚ùå Fallback necesario, usando contenido raw');
            enhancedData = { raw_content: rawContent };
          }
        }

        return {
          enhanced_text: enhancedData,
          original_text: rawText,
          subject: subject,
          processed_at: new Date().toISOString(),
          was_chunked: false
        };
      }
    } catch (error) {
      console.error('‚ùå ERROR CR√çTICO en enhanceTranscription:');
      console.error('üìã Error message:', error.message);
      console.error('üîó Error stack:', error.stack);
      console.error('üìù Texto que caus√≥ el error (primeros 500 chars):', rawText.substring(0, 500) + (rawText.length > 500 ? '...' : ''));
      console.error('üéØ Materia:', subject);
      console.error('üåç Idioma de traducci√≥n:', translationLanguage);
      console.error('‚è∞ Timestamp:', new Date().toISOString());

      console.log('üîÑ Usando mejora local como fallback');
      return this.localEnhancement(rawText, subject, translationLanguage);
    }
  }

  // Mejora local sin dependencia de API externa
  localEnhancement(rawText, subject = 'general', translationLanguage = 'es') {
    console.log(`üéØ Usando mejora local (sin API externa) en idioma: ${translationLanguage}`);

    // Crear estructura b√°sica de mejora
    const words = rawText.split(' ');
    const title = `Transcripci√≥n sobre ${subject}`;

    // Crear secciones b√°sicas
    const sections = [
      {
        type: "heading",
        level: 1,
        content: title
      },
      {
        type: "paragraph",
        content: "Esta transcripci√≥n ha sido procesada localmente sin dependencia de servicios externos."
      },
      {
        type: "paragraph",
        content: rawText
      }
    ];

    // A√±adir secciones adicionales basadas en la longitud del texto
    if (words.length > 50) {
      sections.push({
        type: "heading",
        level: 2,
        content: "Resumen"
      });

      // Crear resumen simple (primeros 100 caracteres)
      const summary = rawText.length > 100 ? rawText.substring(0, 100) + '...' : rawText;
      sections.push({
        type: "summary_block",
        content: summary
      });
    }

    // A√±adir conceptos clave si el texto es suficientemente largo
    if (words.length > 100) {
      sections.push({
        type: "heading",
        level: 2,
        content: "Conceptos Clave"
      });

      // Extraer algunas palabras como conceptos clave
      const keyConcepts = words
        .filter(word => word.length > 5)
        .slice(0, 5)
        .map(word => word.replace(/[.,!?]/g, ''));

      sections.push({
        type: "key_concepts_block",
        concepts: keyConcepts
      });
    }

    const enhancedData = {
      title: title,
      sections: sections,
      key_concepts: [],
      summary: "Transcripci√≥n procesada localmente"
    };

    return {
      enhanced_text: enhancedData,
      original_text: rawText,
      subject: subject,
      processed_at: new Date().toISOString(),
      was_chunked: false,
      is_local: true
    };
  }

  // Generar material de estudio
  async generateStudyMaterial(enhancedText, materialType = 'summary', language = 'es') {
    try {
      // Verificar si tenemos API key v√°lida
      if (!process.env.DEEPSEEK_API_KEY || process.env.DEEPSEEK_API_KEY === 'sk-your-deepseek-api-key-here') {
        console.log('‚ö†Ô∏è  API key de DeepSeek no configurada, usando material de estudio local');
        return this.localStudyMaterial(enhancedText, materialType, language);
      }

      const prompt = this.getStudyPrompt(materialType, language);

      const response = await deepseek.chat([
        {
          role: "system",
          content: prompt
        },
        {
          role: "user",
          content: enhancedText
        }
      ], DEEPSEEK_MODELS.CHAT);

      return {
        type: materialType,
        content: response.choices[0].message.content,
        generated_at: new Date().toISOString(),
        language: language
      };
    } catch (error) {
      console.error('‚ùå Error generando material de estudio:', error.message);
      console.log('üîÑ Usando material de estudio local como fallback');
      return this.localStudyMaterial(enhancedText, materialType, language);
    }
  }

  // Material de estudio local sin dependencia de API externa
  localStudyMaterial(enhancedText, materialType = 'summary', language = 'es') {
    console.log(`üéØ Usando material de estudio local (sin API externa) en idioma: ${language}`);

    const contentMap = {
      es: {
        summary: `Resumen local generado para: ${enhancedText.substring(0, 50)}...`,
        flashcards: JSON.stringify([
          { question: "¬øQu√© es la transcripci√≥n?", answer: "Proceso de convertir audio a texto" },
          { question: "¬øPara qu√© sirve Dicttr?", answer: "Para crear materiales de estudio a partir de grabaciones" }
        ]),
        concepts: "Conceptos clave: transcripci√≥n, estudio, aprendizaje, organizaci√≥n"
      },
      en: {
        summary: `Local summary generated for: ${enhancedText.substring(0, 50)}...`,
        flashcards: JSON.stringify([
          { question: "What is transcription?", answer: "Process of converting audio to text" },
          { question: "What is Dicttr for?", answer: "To create study materials from recordings" }
        ]),
        concepts: "Key concepts: transcription, study, learning, organization"
      },
      fr: {
        summary: `R√©sum√© local g√©n√©r√© pour: ${enhancedText.substring(0, 50)}...`,
        flashcards: JSON.stringify([
          { question: "Qu'est-ce que la transcription?", answer: "Processus de conversion de l'audio en texte" },
          { question: "√Ä quoi sert Dicttr?", answer: "Pour cr√©er des mat√©riaux d'√©tude √† partir d'enregistrements" }
        ]),
        concepts: "Concepts cl√©s: transcription, √©tude, apprentissage, organisation"
      },
      ar: {
        summary: `ŸÖŸÑÿÆÿµ ŸÖÿ≠ŸÑŸä ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ§Ÿá ŸÑŸÄ: ${enhancedText.substring(0, 50)}...`,
        flashcards: JSON.stringify([
          { question: "ŸÖÿß ŸáŸà ÿßŸÑŸÜÿµÿü", answer: "ÿπŸÖŸÑŸäÿ© ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿµŸàÿ™ ÿ•ŸÑŸâ ŸÜÿµ" },
          { question: "ŸÖÿß ŸáŸà ÿßŸÑÿ∫ÿ±ÿ∂ ŸÖŸÜ Dicttrÿü", answer: "ŸÑÿ•ŸÜÿ¥ÿßÿ° ŸÖŸàÿßÿØ ÿØÿ±ÿßÿ≥ÿ© ŸÖŸÜ ÿßŸÑÿ™ÿ≥ÿ¨ŸäŸÑÿßÿ™" }
        ]),
        concepts: "ÿßŸÑŸÖŸÅÿßŸáŸäŸÖ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©: ÿßŸÑŸÜÿµÿå ÿßŸÑÿØÿ±ÿßÿ≥ÿ©ÿå ÿßŸÑÿ™ÿπŸÑŸÖÿå ÿßŸÑÿ™ŸÜÿ∏ŸäŸÖ"
      }
    };

    // Usar el idioma especificado o fallback a espa√±ol
    const languageContent = contentMap[language] || contentMap.es;

    return {
      type: materialType,
      content: languageContent[materialType] || languageContent.summary,
      generated_at: new Date().toISOString(),
      is_local: true,
      language: language
    };
  }

  // Guardar transcripci√≥n en Supabase
  async saveTranscriptionToDB(transcriptionData, userId, fileInfo = null, languageOptions = {}) {
    try {
      if (!supabase) {
        console.warn('Supabase no configurado, guardando localmente');
        return { id: `local_${Date.now()}`, success: true };
      }

    // Generar subject autom√°ticamente si no se proporciona o es "Nueva grabaci√≥n"
    let subject = transcriptionData.subject;
    if (!subject || subject === 'Nueva grabaci√≥n') {
      // Obtener el idioma de traducci√≥n de las opciones de idioma o usar espa√±ol por defecto
      const translationLanguage = languageOptions.translation_language || 'es';
      subject = await this.generateSubjectFromContent(
        transcriptionData.enhanced_text || transcriptionData.original_text, 
        translationLanguage
      );
      // Si falla la generaci√≥n autom√°tica, usar "general" en lugar de "Nueva grabaci√≥n"
      if (!subject) {
        subject = 'general';
        console.log('‚ö†Ô∏è  No se pudo generar subject autom√°tico, usando "general"');
      }
    }

      const transcriptionRecord = {
        user_id: userId,
        title: transcriptionData.enhanced_text?.title || 'Transcripci√≥n sin t√≠tulo',
        subject: subject,
        original_text: transcriptionData.original_text,
        enhanced_text: JSON.stringify(transcriptionData.enhanced_text),
        language: languageOptions.language || transcriptionData.language || 'es',
        translation_language: languageOptions.translation_language || 'es',
        processing_status: 'completed'
      };

      const { data, error } = await supabase
        .from('transcriptions')
        .insert(transcriptionRecord)
        .select();

      if (error) {
        console.error('Error guardando transcripci√≥n en Supabase:', error);
        throw error;
      }

      console.log('‚úÖ Transcripci√≥n guardada en Supabase:', data[0].id);
      return { id: data[0].id, success: true };
    } catch (error) {
      console.error('Error en saveTranscriptionToDB:', error);
      throw error;
    }
  }

  // Guardar documento V2 en Supabase
  async saveDocumentV2ToDB(docData, userId, transcriptionId = null) {
    try {
      if (!supabase) {
        console.warn('Supabase no configurado, guardando localmente');
        return { id: `local_doc_${Date.now()}`, success: true };
      }

      const documentRecord = {
        user_id: userId,
        transcription_id: transcriptionId,
        doc_id: docData.doc_id,
        meta: docData.meta,
        blocks: docData.blocks,
        version: docData.version || 2
      };

      const { data, error } = await supabase
        .from('documents_v2')
        .insert(documentRecord)
        .select();

      if (error) {
        console.error('Error guardando documento V2 en Supabase:', error);
        throw error;
      }

      console.log('‚úÖ Documento V2 guardado en Supabase:', data[0].id);
      return { id: data[0].id, success: true };
    } catch (error) {
      console.error('Error en saveDocumentV2ToDB:', error);
      throw error;
    }
  }

  // Obtener transcripciones del usuario
  async getUserTranscriptions(userId, limit = 50, offset = 0) {
    try {
      if (!supabase) {
        console.warn('Supabase no configurado, devolviendo array vac√≠o');
        return [];
      }

      const { data, error } = await supabase
        .from('transcriptions')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) {
        console.error('Error obteniendo transcripciones:', error);
        throw error;
      }

      return data || [];
    } catch (error) {
      console.error('Error en getUserTranscriptions:', error);
      return [];
    }
  }

  // Obtener documento V2 por ID
  async getDocumentV2ById(docId) {
    try {
      if (!supabase) {
        console.warn('Supabase no configurado, devolviendo null');
        return null;
      }

      const { data, error } = await supabase
        .from('documents_v2')
        .select('*')
        .eq('id', docId)
        .single();

      if (error) {
        console.error('Error obteniendo documento V2:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Error en getDocumentV2ById:', error);
      return null;
    }
  }

  // Actualizar documento V2
  async updateDocumentV2(docId, updates) {
    try {
      if (!supabase) {
        console.warn('Supabase no configurado, actualizaci√≥n simulada');
        return { success: true };
      }

      const { error } = await supabase
        .from('documents_v2')
        .update(updates)
        .eq('id', docId);

      if (error) {
        console.error('Error actualizando documento V2:', error);
        throw error;
      }

      console.log('‚úÖ Documento V2 actualizado:', docId);
      return { success: true };
    } catch (error) {
      console.error('Error en updateDocumentV2:', error);
      throw error;
    }
  }

  // Trackear uso del usuario
  async trackUserUsage(userId, metrics) {
    try {
      if (!supabase) {
        console.warn('Supabase no configurado, tracking deshabilitado');
        return;
      }

      const today = new Date().toISOString().split('T')[0];
      
      await supabase
        .from('usage_metrics')
        .upsert({
          user_id: userId,
          date: today,
          ...metrics
        }, {
          onConflict: 'user_id,date',
          ignoreDuplicates: false
        });

      console.log('üìä Uso trackeado para usuario:', userId, metrics);
    } catch (error) {
      console.error('Error en trackUserUsage:', error);
    }
  }

  // Verificar l√≠mites de uso del usuario
  async checkUserUsageLimits(userId, additionalUsage = { transcription_count: 0, audio_minutes: 0 }) {
    try {
      if (!supabase) {
        // Sin Supabase, permitir uso ilimitado
        return { canProcess: true, limits: null };
      }

      const { data: userData } = await supabase
        .from('users')
        .select('subscription_status')
        .eq('id', userId)
        .single();

      const subscriptionStatus = userData?.subscription_status || 'free';

      // Obtener uso mensual actual
      const monthStart = new Date();
      monthStart.setDate(1);
      const monthStartStr = monthStart.toISOString().split('T')[0];

      const { data: monthlyUsage } = await supabase
        .from('usage_metrics')
        .select('transcription_count, audio_minutes')
        .eq('user_id', userId)
        .gte('date', monthStartStr);

      const totalUsage = monthlyUsage?.reduce((acc, day) => ({
        transcription_count: acc.transcription_count + (day.transcription_count || 0),
        audio_minutes: acc.audio_minutes + (day.audio_minutes || 0)
      }), { transcription_count: 0, audio_minutes: 0 }) || { transcription_count: 0, audio_minutes: 0 };

      // A√±adir uso adicional propuesto
      const proposedUsage = {
        transcription_count: totalUsage.transcription_count + additionalUsage.transcription_count,
        audio_minutes: totalUsage.audio_minutes + additionalUsage.audio_minutes
      };

      // Definir l√≠mites por suscripci√≥n
      const limits = {
        free: { transcriptions: 5, audioMinutes: 30 },
        active: { transcriptions: Infinity, audioMinutes: subscriptionStatus === 'pro' ? 300 : 1200 }
      };

      const userLimits = limits[subscriptionStatus] || limits.free;

      const canProcess = 
        proposedUsage.transcription_count <= userLimits.transcriptions &&
        proposedUsage.audio_minutes <= userLimits.audioMinutes;

      return {
        canProcess,
        limits: {
          current: totalUsage,
          proposed: proposedUsage,
          max: userLimits,
          subscription: subscriptionStatus
        }
      };
    } catch (error) {
      console.error('Error en checkUserUsageLimits:', error);
      return { canProcess: true, limits: null }; // Permitir en caso de error
    }
  }

  // Prompts especializados por materia
  getSystemPrompt(subject, translationLanguage = 'es') {
    const basePrompt = `Eres Dicttr AI, un asistente especializado en mejorar transcripciones de audio para todo tipo de contenido.

Tu objetivo es:
1. Estructurar el contenido de forma clara y organizada
2. Corregir errores de transcripci√≥n y eliminar muletillas
3. Mejorar la legibilidad y coherencia del texto
4. Organizar la informaci√≥n en secciones l√≥gicas
5. Mantener un lenguaje claro y profesional
6. Crear bloques editables para cada elemento importante

üö®üö®üö® INSTRUCCI√ìN CR√çTICA: 
- Genera TODO el contenido mejorado EXCLUSIVAMENTE en el idioma "${translationLanguage}"
- El t√≠tulo, p√°rrafos, definiciones, ejemplos y res√∫menes DEBEN estar en "${translationLanguage}"
- NO mezcles idiomas bajo ninguna circunstancia
- Si el idioma es √°rabe ("ar"), usa escritura de derecha a izquierda y caracteres √°rabes

IMPORTANTE: Devuelve el contenido en formato JSON estructurado con el siguiente schema:

{
  "title": "T√≠tulo principal del contenido",
  "sections": [
    {
      "type": "heading",
      "level": 1|2|3,
      "content": "Texto del encabezado"
    },
    {
      "type": "paragraph", 
      "content": "Contenido del p√°rrafo"
    },
    {
      "type": "list",
      "style": "bulleted|numbered",
      "items": ["Item 1", "Item 2", "Item 3"]
    },
    {
      "type": "concept_block",
      "term": "T√©rmino del concepto",
      "definition": "Definici√≥n detallada",
      "examples": ["Ejemplo 1", "Ejemplo 2"]
    },
    {
      "type": "summary_block",
      "content": "Resumen completo del tema"
    },
    {
      "type": "key_concepts_block",
      "concepts": ["Concepto 1", "Concepto 2", "Concepto 3"]
    }
  ]
}

Reglas:
- Usa "concept_block" para conceptos individuales con definiciones
- Usa "summary_block" para res√∫menes generales
- Usa "key_concepts_block" para listas de conceptos clave
- Todos los bloques deben ser editables individualmente
- Organiza el contenido de forma l√≥gica y coherente
- Incluye tantos bloques como necesites para cubrir el tema completamente
- Solo devuelve JSON v√°lido, sin texto adicional
- üö® TODO el contenido DEBE estar en "${translationLanguage}"`;

    const subjectPrompts = {
      medicina: basePrompt + "\n\nEnf√≥cate en terminolog√≠a m√©dica, procesos fisiol√≥gicos y casos cl√≠nicos.",
      ingenieria: basePrompt + "\n\nPrioriza f√≥rmulas, procesos t√©cnicos y aplicaciones pr√°cticas.",
      derecho: basePrompt + "\n\nDestaca conceptos legales, jurisprudencia y casos de estudio.",
      ciencias: basePrompt + "\n\nExplica fen√≥menos cient√≠ficos, teor√≠as y metodolog√≠as experimentales.",
      negocios: basePrompt + "\n\nEnf√≥cate en terminolog√≠a empresarial, estrategias y an√°lisis de mercado.",
      tecnologia: basePrompt + "\n\nPrioriza conceptos t√©cnicos, procesos y aplicaciones tecnol√≥gicas.",
      general: basePrompt
    };

    return subjectPrompts[subject] || subjectPrompts.general;
  }

  // Prompts para diferentes tipos de material de estudio
  getStudyPrompt(materialType, language = 'es') {
    const prompts = {
      es: {
        summary: "Genera un resumen estructurado con los puntos clave organizados en secciones. M√°ximo 300 palabras.",
        flashcards: "Crea 5-8 flashcards en formato JSON con 'question' y 'answer'. Enf√≥cate en conceptos clave.",
        concepts: "Identifica y explica los 3-5 conceptos m√°s importantes del texto. Para cada concepto incluye: definici√≥n, importancia y ejemplos.",
        quiz: "Crea 5 preguntas de opci√≥n m√∫ltiple basadas en el contenido. Formato JSON con pregunta, opciones (a,b,c,d) y respuesta correcta.",
        flowchart: "Genera un flujograma en sintaxis Mermaid que represente el proceso o sistema descrito. Usa formato claro con nodos rectangulares para procesos, rombos para decisiones, y flechas para flujo. Incluye solo el c√≥digo Mermaid sin explicaciones."
      },
      en: {
        summary: "Generate a structured summary with key points organized in sections. Maximum 300 words.",
        flashcards: "Create 5-8 flashcards in JSON format with 'question' and 'answer'. Focus on key concepts.",
        concepts: "Identify and explain the 3-5 most important concepts in the text. For each concept include: definition, importance, and examples.",
        quiz: "Create 5 multiple-choice questions based on the content. JSON format with question, options (a,b,c,d) and correct answer.",
        flowchart: "Generate a flowchart in Mermaid syntax that represents the described process or system. Use clear format with rectangular nodes for processes, diamonds for decisions, and arrows for flow. Include only the Mermaid code without explanations."
      },
      fr: {
        summary: "G√©n√©rez un r√©sum√© structur√© avec les points cl√©s organis√©s en sections. Maximum 300 mots.",
        flashcards: "Cr√©ez 5-8 flashcards au format JSON avec 'question' et 'answer'. Concentrez-vous sur les concepts cl√©s.",
        concepts: "Identifiez et expliquez les 3-5 concepts les plus importants du texte. Pour chaque concept incluez: d√©finition, importance et exemples.",
        quiz: "Cr√©ez 5 questions √† choix multiples bas√©es sur le contenu. Format JSON avec question, options (a,b,c,d) et r√©ponse correcte.",
        flowchart: "G√©n√©rez un organigramme en syntaxe Mermaid qui repr√©sente le processus ou syst√®me d√©crit. Utilisez un format clair avec des n≈ìuds rectangulaires pour les processus, des losanges pour les d√©cisions, et des fl√®ches pour le flux. Incluez uniquement le code Mermaid sans explications."
      }
    };

    // Usar el idioma especificado o fallback a espa√±ol
    const languagePrompts = prompts[language] || prompts.es;
    return languagePrompts[materialType] || languagePrompts.summary;
  }

  // Generar flujograma espec√≠ficamente
  async generateFlowchart(text, subject = 'general') {
    try {
      // Verificar si tenemos API key v√°lida
      if (!process.env.DEEPSEEK_API_KEY || process.env.DEEPSEEK_API_KEY === 'sk-your-deepseek-api-key-here') {
        console.log('‚ö†Ô∏è  API key de DeepSeek no configurada, usando flujograma local');
        return this.localFlowchart(text, subject);
      }

      const systemPrompt = `Eres un experto en crear flujogramas educativos.

Genera un flujograma en sintaxis Mermaid para representar visualmente el proceso descrito.

Reglas:
- Usa graph TD para diagramas de flujo
- Nodos rectangulares [proceso] para acciones
- Rombos {decisi√≥n} para puntos de elecci√≥n
- Flechas --> para conectar elementos
- Mant√©n el dise√±o limpio y educativo
- Incluye solo el c√≥digo Mermaid, sin explicaciones

Ejemplo:
\`\`\`mermaid
graph TD
  A[Inicio] --> B[Proceso 1]
  B --> C{Decisi√≥n}
  C -->|S√≠| D[Resultado 1]
  C -->|No| E[Resultado 2]
\`\`\``;

      console.log('üîç Generando flujograma para:', subject);
      console.log('üìù Texto de entrada:', text.substring(0, 100) + '...');

      const response = await deepseek.chat([
        {
          role: "system",
          content: systemPrompt
        },
        {
          role: "user",
          content: `Crea un flujograma Mermaid para este contenido sobre ${subject}:\n\n${text}`
        }
      ], DEEPSEEK_MODELS.CHAT);

      console.log('‚úÖ Respuesta de DeepSeek recibida');

      // Extraer solo el c√≥digo Mermaid (puede venir entre ```mermaid ```)
      let mermaidCode = response.choices[0].message.content || '';
      console.log('üìã Contenido crudo:', mermaidCode.substring(0, 100) + '...');

      const mermaidMatch = mermaidCode.match(/```mermaid\s*([\s\S]*?)\s*```/);
      if (mermaidMatch && mermaidMatch[1]) {
        mermaidCode = mermaidMatch[1].trim();
        console.log('üéØ C√≥digo Mermaid extra√≠do:', mermaidCode.substring(0, 100) + '...');
      } else {
        // Si no est√° en formato de c√≥digo, usar el texto completo
        mermaidCode = mermaidCode.trim();
        console.log('‚ÑπÔ∏è  Usando contenido completo como Mermaid:', mermaidCode.substring(0, 100) + '...');
      }

      const result = {
        type: 'flowchart',
        mermaid_code: mermaidCode,
        content: response.choices[0].message.content,
        generated_at: new Date().toISOString()
      };

      console.log('üìä Resultado final:', JSON.stringify(result, null, 2));

      return result;
    } catch (error) {
      console.error('‚ùå Error generando flujograma:', error.message);
      console.log('üîÑ Usando flujograma local como fallback');
      return this.localFlowchart(text, subject);
    }
  }

  // Flujograma local sin dependencia de API externa
  localFlowchart(text, subject = 'general') {
    console.log('üéØ Usando flujograma local (sin API externa)');

    const mermaidCode = `graph TD
  A[Inicio del Proceso] --> B[An√°lisis del Contenido]
  B --> C{¬øEs ${subject}?}
  C -->|S√≠| D[Procesar ${subject}]
  C -->|No| E[Procesar General]
  D --> F[Generar Resultados]
  E --> F
  F --> G[Fin del Proceso]`;

    return {
      type: 'flowchart',
      mermaid_code: mermaidCode,
      content: `Flujograma local generado para: ${subject}`,
      generated_at: new Date().toISOString(),
      is_local: true
    };
  }

  // Expandir texto con IA (para editor de bloques)
  async expandText(text, subject = 'general') {
    try {
      // Verificar si tenemos API key v√°lida
      if (!process.env.DEEPSEEK_API_KEY || process.env.DEEPSEEK_API_KEY === 'sk-your-deepseek-api-key-here') {
        console.log('‚ö†Ô∏è  API key de DeepSeek no configurada, usando expansi√≥n local');
        return this.localExpandText(text, subject);
      }

      const systemPrompt = `Eres Dicttr AI, un asistente educativo especializado en ampliar y enriquecer contenido acad√©mico.

Tu objetivo es:
1. Ampliar el texto proporcionado con informaci√≥n relevante y educativa
2. A√±adir ejemplos, explicaciones y contexto adicional
3. Mantener coherencia con el tema y estilo original
4. Organizar el contenido de forma estructurada y did√°ctica
5. Usar lenguaje acad√©mico pero accesible

Formato de salida en Markdown con estructura clara.`;

      const subjectPrompts = {
        medicina: systemPrompt + "\n\nEnf√≥cate en terminolog√≠a m√©dica, procesos fisiol√≥gicos y casos cl√≠nicos relevantes.",
        ingenieria: systemPrompt + "\n\nPrioriza aplicaciones pr√°cticas, f√≥rmulas relevantes y ejemplos t√©cnicos.",
        derecho: systemPrompt + "\n\nDestaca conceptos legales, jurisprudencia relevante y casos de estudio.",
        ciencias: systemPrompt + "\n\nExplica fen√≥menos cient√≠ficos, teor√≠as relacionadas y metodolog√≠as.",
        general: systemPrompt
      };

      const finalPrompt = subjectPrompts[subject] || subjectPrompts.general;

      const response = await deepseek.chat([
        {
          role: "system",
          content: finalPrompt
        },
        {
          role: "user",
          content: `Ampl√≠a y enriquece este contenido sobre ${subject}:\n\n${text}`
        }
      ], DEEPSEEK_MODELS.CHAT);

      return {
        expanded_text: response.choices[0].message.content,
        original_text: text,
        subject: subject,
        processed_at: new Date().toISOString()
      };
    } catch (error) {
      console.error('‚ùå Error expandiendo texto:', error.message);
      console.log('üîÑ Usando expansi√≥n local como fallback');
      return this.localExpandText(text, subject);
    }
  }

  // Expansi√≥n local de texto sin dependencia de API externa
  localExpandText(text, subject = 'general') {
    console.log('üéØ Usando expansi√≥n local de texto (sin API externa)');

    const expandedText = `# Texto Ampliado sobre ${subject}

## Contenido Original:
${text}

## Informaci√≥n Adicional:
Este texto ha sido ampliado localmente para proporcionar contexto educativo adicional relacionado con ${subject}. La expansi√≥n local incluye informaci√≥n b√°sica y ejemplos relevantes para facilitar el aprendizaje.

## Ejemplo de Aplicaci√≥n:
El contenido original puede ser utilizado para crear materiales de estudio, res√∫menes o presentaciones educativas sobre ${subject}.

## Nota:
Esta expansi√≥n fue generada localmente sin dependencia de servicios externos de IA.`;

    return {
      expanded_text: expandedText,
      original_text: text,
      subject: subject,
      processed_at: new Date().toISOString(),
      is_local: true
    };
  }

  // Estimar duraci√≥n del archivo de audio
  estimateDuration(audioFile) {
    try {
      const stats = fs.statSync(audioFile);
      // Estimaci√≥n aproximada: 1MB ‚âà 1 minuto de audio
      return Math.round(stats.size / (1024 * 1024));
    } catch {
      return 120;
    }
  }

  // Dividir texto en chunks para procesamiento de textos largos
  splitTextIntoChunks(text, maxChunkSize = 20000) {
    const chunks = [];
    let currentChunk = '';
    const sentences = text.split(/(?<=[.!?])\s+/);
    
    for (const sentence of sentences) {
      if ((currentChunk + sentence).length > maxChunkSize && currentChunk.length > 0) {
        chunks.push(currentChunk.trim());
        currentChunk = sentence;
      } else {
        currentChunk += ' ' + sentence;
      }
    }
    
    if (currentChunk.trim().length > 0) {
      chunks.push(currentChunk.trim());
    }
    
    return chunks;
  }

  // Parsear texto mejorado a bloques estructurados (h1, h2, p√°rrafos, listas)
  parseTextToBlocks(text) {
    const blocks = [];
    const lines = text.split('\n').filter(line => line.trim().length > 0);
    let blockId = 1;
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // Detectar encabezados
      if (trimmedLine.match(/^#{1,3}\s+.+$/)) {
        const level = trimmedLine.match(/^#{1,3}/)[0].length;
        const textContent = trimmedLine.replace(/^#{1,3}\s+/, '');
        
        blocks.push({
          id: `block_${blockId++}`,
          type: `h${level}`,
          text: textContent,
          tags: ['heading']
        });
      
      // Detectar listas
      } else if (trimmedLine.match(/^[-‚Ä¢*]\s/)) {
        blocks.push({
          id: `block_${blockId++}`,
          type: 'bulleted_list',
          items: [trimmedLine.replace(/^[-‚Ä¢*]\s/, '')],
          tags: ['list']
        });
      
      } else if (trimmedLine.match(/^\d+\.\s/)) {
        blocks.push({
          id: `block_${blockId++}`,
          type: 'numbered_list',
          items: [trimmedLine.replace(/^\d+\.\s/, '')],
          tags: ['list']
        });
      
      // P√°rrafos normales
      } else {
        blocks.push({
          id: `block_${blockId++}`,
          type: 'paragraph',
          text: trimmedLine,
          tags: []
        });
      }
    }
    
    return blocks;
  }

  // Convertir JSON estructurado a bloques para compatibilidad
  jsonToBlocks(jsonData) {
    const blocks = [];
    let blockId = 1;

    // A√±adir t√≠tulo principal
    if (jsonData.title) {
      blocks.push({
        id: `block_${blockId++}`,
        type: 'h1',
        text: jsonData.title,
        tags: ['heading', 'title']
      });
    }

    // Procesar secciones
    if (jsonData.sections && Array.isArray(jsonData.sections)) {
      for (const section of jsonData.sections) {
        switch (section.type) {
          case 'heading':
            blocks.push({
              id: `block_${blockId++}`,
              type: `h${section.level || 2}`,
              text: section.content,
              tags: ['heading']
            });
            break;
          
          case 'paragraph':
            blocks.push({
              id: `block_${blockId++}`,
              type: 'paragraph',
              text: section.content,
              tags: []
            });
            break;
          
          case 'list':
            blocks.push({
              id: `block_${blockId++}`,
              type: section.style === 'numbered' ? 'numbered_list' : 'bulleted_list',
              items: section.items || [],
              tags: ['list']
            });
            break;
          
          case 'concept_block':
            blocks.push({
              id: `block_${blockId++}`,
              type: 'concept_block',
              term: section.term || '',
              definition: section.definition || '',
              examples: section.examples || [],
              tags: ['concept', 'editable']
            });
            break;
          
          case 'summary_block':
            blocks.push({
              id: `block_${blockId++}`,
              type: 'summary_block',
              content: section.content || '',
              tags: ['summary', 'editable']
            });
            break;
          
          case 'key_concepts_block':
            blocks.push({
              id: `block_${blockId++}`,
              type: 'key_concepts_block',
              concepts: section.concepts || [],
              tags: ['key_concepts', 'editable']
            });
            break;
        }
      }
    }

    return blocks;
  }

  // Generar bloque espec√≠fico con IA usando contexto
  async generateBlock(blockType, userPrompt, contextText, subject = 'general') {
    try {
      // Detectar si el usuario solicita un tipo de bloque diferente
      let finalBlockType = blockType;
      
      // An√°lisis del prompt del usuario para detectar intenci√≥n
      const userPromptLower = userPrompt.toLowerCase();
      
      if (userPromptLower.includes('listado') || 
          userPromptLower.includes('lista') || 
          userPromptLower.includes('enumera') || 
          userPromptLower.includes('puntos') ||
          userPromptLower.includes('items') ||
          userPromptLower.includes('elementos')) {
        console.log('üéØ Detectada intenci√≥n de lista, cambiando blockType a list');
        finalBlockType = 'list';
      } else if (userPromptLower.includes('conceptos clave') || 
                 userPromptLower.includes('key concepts') || 
                 userPromptLower.includes('conceptos principales')) {
        console.log('üéØ Detectada intenci√≥n de conceptos clave, cambiando blockType a key_concepts_block');
        finalBlockType = 'key_concepts_block';
      } else if (userPromptLower.includes('concepto') || 
                 userPromptLower.includes('definici√≥n') || 
                 userPromptLower.includes('definir')) {
        console.log('üéØ Detectada intenci√≥n de concepto, cambiando blockType a concept_block');
        finalBlockType = 'concept_block';
      } else if (userPromptLower.includes('resumen') || 
                 userPromptLower.includes('resumir')) {
        console.log('üéØ Detectada intenci√≥n de resumen, cambiando blockType a summary_block');
        finalBlockType = 'summary_block';
      } else if (userPromptLower.includes('t√≠tulo') || 
                 userPromptLower.includes('titulo') || 
                 userPromptLower.includes('heading') || 
                 userPromptLower.includes('encabezado') ||
                 userPromptLower.includes('cabecera')) {
        console.log('üéØ Detectada intenci√≥n de t√≠tulo/encabezado, cambiando blockType a heading');
        finalBlockType = 'heading';
      }
      
      const systemPrompt = this.getBlockGenerationPrompt(finalBlockType, subject);

      console.log('üîç Generando bloque con IA - Tipo solicitado:', blockType);
      console.log('üîç Tipo final detectado:', finalBlockType);
      console.log('üìù Prompt del usuario:', userPrompt.substring(0, 100) + '...');
      console.log('üìã Contexto length:', contextText.length);
      console.log('üîç Muestra del contexto (primeros 200 chars):', contextText.substring(0, 200) + '...');
      
      // Truncar contexto si es demasiado largo para evitar que domine sobre la instrucci√≥n del usuario
      // Tambi√©n extraer texto si el contexto es un objeto JSON
      let processedContext = contextText;
      
      // Si el contexto parece ser JSON, extraer solo el texto
      try {
        if (contextText.trim().startsWith('{') || contextText.trim().startsWith('[')) {
          const contextData = JSON.parse(contextText);
          // Extraer todo el texto de las secciones
          if (contextData.sections && Array.isArray(contextData.sections)) {
            processedContext = contextData.sections
              .map(section => section.content || section.text || '')
              .filter(Boolean)
              .join('\n');
            console.log('üîÑ Contexto JSON convertido a texto plano, length:', processedContext.length);
          }
        }
      } catch (e) {
        console.log('‚ÑπÔ∏è  Contexto no es JSON v√°lido, usando como texto plano');
      }
      
      const truncatedContext = processedContext.length > 1000 ? 
        processedContext.substring(0, 1000) + '... [contexto truncado]' : 
        processedContext;
      
      const fullPrompt = `‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è INSTRUCCI√ìN PRINCIPAL DEL USUARIO (OBLIGATORIO - IGNORAR CONTEXTO SI ES NECESARIO):\n${userPrompt}\n\nüí° CONTEXTO DE FONDO (SOLO PARA REFERENCIA - NO ES OBLIGATORIO USARLO):\n${truncatedContext}\n\nüö® GENERA EXCLUSIVAMENTE EL BLOQUE SOLICITADO EN FORMATO JSON, SIGUIENDO √öNICAMENTE LA INSTRUCCI√ìN PRINCIPAL DEL USUARIO:`;
      
      let response;
      try {
        // Verificar si tenemos API key v√°lida
        if (!process.env.DEEPSEEK_API_KEY || process.env.DEEPSEEK_API_KEY === 'sk-your-deepseek-api-key-here') {
          console.log('‚ö†Ô∏è  API key de DeepSeek no configurada, usando bloque local');
          return this.localGenerateBlock(blockType, userPrompt, contextText, subject);
        }

        response = await deepseek.chat([
          {
            role: "system",
            content: systemPrompt
          },
          {
            role: "user",
            content: fullPrompt
          }
        ], DEEPSEEK_MODELS.CHAT);

        console.log('‚úÖ Respuesta de DeepSeek recibida');
        console.log('üìÑ Contenido crudo:', response.choices[0].message.content.substring(0, 200) + '...');
      } catch (apiError) {
        console.error('‚ùå Error en API de DeepSeek:', apiError.message);
        console.log('üîÑ Usando bloque local como fallback');
        return this.localGenerateBlock(blockType, userPrompt, contextText, subject);
      }

      // Parsear la respuesta JSON, manejando posibles code blocks
      let generatedData;
      let rawContent = response.choices[0]?.message?.content;
      
      if (!rawContent) {
        console.error('‚ùå Respuesta de DeepSeek vac√≠a o inv√°lida:', response);
        throw new Error('La API de DeepSeek devolvi√≥ una respuesta vac√≠a');
      }
      
      try {
        // Intentar extraer JSON de code blocks markdown primero
        const jsonMatch = rawContent.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          console.log('üéØ Extrayendo JSON de code block');
          generatedData = JSON.parse(jsonMatch[1].trim());
        } else {
          // Si no hay code blocks, parsear directamente
          generatedData = JSON.parse(rawContent);
        }
        console.log('üéØ JSON parseado correctamente:', JSON.stringify(generatedData, null, 2));
      } catch (error) {
        console.warn('‚ùå Error parsing block JSON:', error.message);
        console.warn('üìã Contenido que fall√≥:', rawContent);
        
        // Intentar limpiar el contenido y parsear nuevamente
        try {
          const cleanedContent = rawContent
            .replace(/```(?:json)?/g, '')
            .replace(/```/g, '')
            .trim();
          
          if (cleanedContent !== rawContent) {
            console.log('üîÑ Intentando parsear contenido limpiado');
            generatedData = JSON.parse(cleanedContent);
            console.log('‚úÖ Parseo exitoso despu√©s de limpieza');
          } else {
            throw new Error('No se pudo limpiar el contenido');
          }
        } catch (cleanError) {
          console.warn('‚ùå Fallback necesario, usando contenido raw');
          // Fallback: crear bloque b√°sico con el contenido raw
          generatedData = this.createFallbackBlock(blockType, rawContent);
          console.log('üîÑ Usando fallback:', JSON.stringify(generatedData, null, 2));
        }
      }

      return {
        block_type: blockType,
        generated_content: generatedData,
        user_prompt: userPrompt,
        generated_at: new Date().toISOString()
      };

    } catch (error) {
      throw new Error(`Error generando bloque ${blockType}: ${error.message}`);
    }
  }

  // Prompt especializado para generaci√≥n de bloques
  getBlockGenerationPrompt(blockType, subject) {
    const basePrompt = `Eres Dicttr AI, especializado en generar contenido educativo para bloques espec√≠ficos.

INSTRUCCIONES CR√çTICAS:
1. üö® SIGUE EXACTAMENTE LA INSTRUCCI√ìN DEL USUARIO - IGNORA COMPLETAMENTE EL CONTEXTO SI CONTRADICE LA INSTRUCCI√ìN
2. Usa el CONTEXTO proporcionado SOLO si es compatible con la instrucci√≥n del usuario
3. Devuelve SOLO el bloque solicitado en formato JSON v√°lido
4. Si el contexto contradice la instrucci√≥n del usuario, IGNORA EL CONTEXTO COMPLETAMENTE
5. Usa lenguaje acad√©mico pero accesible
6. EL TIPO DE BLOQUE DEBE SER EXACTAMENTE EL SOLICITADO: ${blockType}

IMPORTANTE: 
- Solo devuelve el objeto JSON del bloque, sin texto adicional
- NO usa markdown code blocks (\`\`\`json o \`\`\`)
- Devuelve SOLO el objeto JSON crudo, sin comentarios ni explicaciones
- Aseg√∫rate de que el JSON sea v√°lido y est√© bien formado`;

    const blockPrompts = {
      heading: basePrompt + `\n\nFormato EXACTO para heading: { "type": "heading", "level": 2, "content": "Texto del encabezado" }`,
      paragraph: basePrompt + `\n\nFormato EXACTO para paragraph: { "type": "paragraph", "content": "Contenido del p√°rrafo" }`,
      list: basePrompt + `\n\nFormato EXACTO para list: { "type": "list", "style": "bulleted", "items": ["item 1", "item 2"] }`,
      concept_block: basePrompt + `\n\nFormato EXACTO para concept_block: { "type": "concept_block", "term": "T√©rmino", "definition": "Definici√≥n", "examples": ["ejemplo 1", "ejemplo 2"] }`,
      summary_block: basePrompt + `\n\nFormato EXACTO para summary_block: { "type": "summary_block", "content": "Contenido del resumen" }`,
      key_concepts_block: basePrompt + `\n\nFormato EXACTO para key_concepts_block: { "type": "key_concepts_block", "concepts": ["concepto 1", "concepto 2", "concepto 3"] }`,
      example: basePrompt + `\n\nFormato EXACTO para example: { "type": "example", "content": "Contenido del ejemplo" }`
    };

    const subjectContext = {
      medicina: "Enf√≥cate en terminolog√≠a m√©dica y casos cl√≠nicos.",
      ingenieria: "Prioriza aplicaciones pr√°cticas y ejemplos t√©cnicos.",
      derecho: "Destaca conceptos legales y jurisprudencia.",
      ciencias: "Explica fen√≥menos cient√≠ficos y metodolog√≠as.",
      general: ""
    };

    return blockPrompts[blockType] + subjectContext[subject] || subjectContext.general;
  }

  // Crear bloque de fallback si el parsing falla
  createFallbackBlock(blockType, content) {
    const fallbacks = {
      heading: { type: "heading", level: 2, content },
      paragraph: { type: "paragraph", content },
      list: { type: "list", style: "bulleted", items: [content] },
      concept_block: { type: "concept_block", term: "Concepto", definition: content, examples: [] },
      summary_block: { type: "summary_block", content },
      key_concepts_block: { type: "key_concepts_block", concepts: [content] }
    };
    
    return fallbacks[blockType] || { type: "paragraph", content };
  }

  // Convertir segments de transcripci√≥n a formato DocBlocksV2
  convertToDocBlocksV2(segments, language = 'es') {
    const blocks = [];
    let blockId = 1;

    for (const segment of segments) {
      const block = {
        id: `block_${blockId++}`,
        type: 'paragraph',
        time: {
          start: Math.round(segment.start),
          end: Math.round(segment.end)
        },
        confidence: segment.confidence || 0.8,
        speaker: null, // Por defecto, sin diarizaci√≥n
        tags: [],
        text: segment.text.trim()
      };

      // Detectar si es un encabezado (basado en contenido)
      if (segment.text.match(/^#\s+|^##\s+|^###\s+|^[A-Z√Å√â√ç√ì√ö√ë\s]{10,}:$/)) {
        if (segment.text.match(/^#\s+/)) {
          block.type = 'h1';
          block.text = segment.text.replace(/^#\s+/, '');
        } else if (segment.text.match(/^##\s+/)) {
          block.type = 'h2';
          block.text = segment.text.replace(/^##\s+/, '');
        } else if (segment.text.match(/^###\s+/)) {
          block.type = 'h3';
          block.text = segment.text.replace(/^###\s+/, '');
        } else if (segment.text.match(/^[A-Z√Å√â√ç√ì√ö√ë\s]{10,}:$/)) {
          block.type = 'h2';
        }
      }

      // Detectar si es una lista
      if (segment.text.match(/^[-‚Ä¢*]\s/)) {
        block.type = 'bulleted_list';
        block.items = [segment.text.replace(/^[-‚Ä¢*]\s/, '')];
        delete block.text;
      } else if (segment.text.match(/^\d+\.\s/)) {
        block.type = 'numbered_list';
        block.items = [segment.text.replace(/^\d+\.\s/, '')];
        delete block.text;
      }

      blocks.push(block);
    }

    return {
      doc_id: `doc_${Date.now()}`,
      meta: {
        curso: 'general',
        asignatura: 'transcripci√≥n',
        idioma: language
      },
      blocks: blocks,
      version: 2
    };
  }

  // Traducir asunto a diferentes idiomas
  translateSubject(subject, targetLanguage = 'es') {
    const subjectTranslations = {
      // Espa√±ol (base)
      es: {
        'general': 'general',
        'medicina': 'medicina',
        'ingenieria': 'ingenier√≠a',
        'derecho': 'derecho',
        'ciencias': 'ciencias',
        'negocios': 'negocios',
        'tecnologia': 'tecnolog√≠a'
      },
      // Ingl√©s
      en: {
        'general': 'general',
        'medicina': 'medicine',
        'ingenieria': 'engineering',
        'derecho': 'law',
        'ciencias': 'sciences',
        'negocios': 'business',
        'tecnologia': 'technology'
      },
      // Franc√©s
      fr: {
        'general': 'g√©n√©ral',
        'medicina': 'm√©decine',
        'ingenieria': 'ing√©nierie',
        'derecho': 'droit',
        'ciencias': 'sciences',
        'negocios': 'affaires',
        'tecnologia': 'technologie'
      },
      // Alem√°n
      de: {
        'general': 'allgemein',
        'medicina': 'medizin',
        'ingenieria': 'ingenieurwesen',
        'derecho': 'recht',
        'ciencias': 'wissenschaften',
        'negocios': 'gesch√§ft',
        'tecnologia': 'technologie'
      },
      // Italiano
      it: {
        'general': 'generale',
        'medicina': 'medicina',
        'ingenieria': 'ingegneria',
        'derecho': 'diritto',
        'ciencias': 'scienze',
        'negocios': 'affari',
        'tecnologia': 'tecnologia'
      },
      // Portugu√©s
      pt: {
        'general': 'geral',
        'medicina': 'medicina',
        'ingenieria': 'engenharia',
        'derecho': 'direito',
        'ciencias': 'ci√™ncias',
        'negocios': 'neg√≥cios',
        'tecnologia': 'tecnologia'
      },
      // Ruso
      ru: {
        'general': '–æ–±—â–∏–π',
        'medicina': '–º–µ–¥–∏—Ü–∏–Ω–∞',
        'ingenieria': '–∏–Ω–∂–µ–Ω–µ—Ä–∏—è',
        'derecho': '–ø—Ä–∞–≤–æ',
        'ciencias': '–Ω–∞—É–∫–∏',
        'negocios': '–±–∏–∑–Ω–µ—Å',
        'tecnologia': '—Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è'
      },
      // Japon√©s
      ja: {
        'general': '‰∏ÄËà¨',
        'medicina': 'ÂåªÂ≠¶',
        'ingenieria': 'Â∑•Â≠¶',
        'derecho': 'Ê≥ïÂæã',
        'ciencias': 'ÁßëÂ≠¶',
        'negocios': '„Éì„Ç∏„Éç„Çπ',
        'tecnologia': 'ÊäÄË°ì'
      },
      // Chino
      zh: {
        'general': '‰∏ÄËà¨',
        'medicina': 'ÂåªÂ≠¶',
        'ingenieria': 'Â∑•Á®ã',
        'derecho': 'Ê≥ïÂæã',
        'ciencias': 'ÁßëÂ≠¶',
        'negocios': 'ÂïÜ‰∏ö',
        'tecnologia': 'ÊäÄÊúØ'
      },
      // √Årabe
      ar: {
        'general': 'ÿπÿßŸÖ',
        'medicina': 'ÿ∑ÿ®',
        'ingenieria': 'ŸáŸÜÿØÿ≥ÿ©',
        'derecho': 'ŸÇÿßŸÜŸàŸÜ',
        'ciencias': 'ÿπŸÑŸàŸÖ',
        'negocios': 'ÿ£ÿπŸÖÿßŸÑ',
        'tecnologia': 'ÿ™ŸÉŸÜŸàŸÑŸàÿ¨Ÿäÿß'
      }
    };

    // Usar traducci√≥n si existe, si no usar el original
    const languageTranslations = subjectTranslations[targetLanguage] || subjectTranslations.es;
    return languageTranslations[subject] || subject;
  }

  // Generar asunto autom√°tico con IA basado en el contenido
  async generateSubjectFromContent(content, translationLanguage = 'es') {
    try {
      console.log('ü§ñ Generando asunto autom√°tico con IA...');
      console.log('üåç Idioma para asunto:', translationLanguage);

      // Si el contenido es un objeto JSON, extraer el texto
      let textContent = content;
      if (typeof content === 'object' && content !== null) {
        // Extraer texto de diferentes formatos posibles
        if (content.text) {
          textContent = content.text;
        } else if (content.content) {
          textContent = content.content;
        } else if (content.enhanced_text && typeof content.enhanced_text === 'object') {
          // Extraer texto de enhanced_text estructurado
          textContent = this.extractTextFromEnhancedContent(content.enhanced_text);
        } else if (content.original_text) {
          textContent = content.original_text;
        } else {
          // Fallback: convertir a string
          textContent = JSON.stringify(content);
        }
      }

      // Limitar el texto para evitar tokens excesivos
      const truncatedText = textContent.length > 1000
        ? textContent.substring(0, 1000) + '...'
        : textContent;

      // Definir prompts por idioma
      const subjectPrompts = {
        es: `Eres Dicttr AI, especializado en an√°lisis de contenido educativo.

Tu tarea es analizar el contenido proporcionado y generar un asunto/tema apropiado que describa de qu√© trata el material.

INSTRUCCIONES:
1. Analiza el contenido y extrae el tema principal
2. Genera un asunto conciso (m√°ximo 3-5 palabras)
3. Usa categor√≠as educativas comunes como: matem√°ticas, f√≠sica, qu√≠mica, biolog√≠a, historia, literatura, programaci√≥n, medicina, derecho, econom√≠a, etc.
4. Si no puedes determinar el tema, devuelve "general"
5. Devuelve SOLO el asunto, sin explicaciones ni texto adicional

Ejemplos de respuestas v√°lidas:
- "matem√°ticas"
- "historia antigua"
- "programaci√≥n web"
- "biolog√≠a celular"
- "general"`,

        en: `You are Dicttr AI, specialized in educational content analysis.

Your task is to analyze the provided content and generate an appropriate subject/topic that describes what the material is about.

INSTRUCTIONS:
1. Analyze the content and extract the main topic
2. Generate a concise subject (maximum 3-5 words)
3. Use common educational categories like: mathematics, physics, chemistry, biology, history, literature, programming, medicine, law, economics, etc.
4. If you cannot determine the topic, return "general"
5. Return ONLY the subject, without explanations or additional text

Valid response examples:
- "mathematics"
- "ancient history"
- "web programming"
- "cell biology"
- "general"`,

        fr: `Vous √™tes Dicttr AI, sp√©cialis√© dans l'analyse de contenu √©ducatif.

Votre t√¢che est d'analyser le contenu fourni et de g√©n√©rer un sujet/th√®me appropri√© qui d√©crit le contenu du mat√©riel.

INSTRUCTIONS:
1. Analysez le contenu et extrayez le th√®me principal
2. G√©n√©rez un sujet concis (maximum 3-5 mots)
3. Utilisez des cat√©gories √©ducatives courantes comme: math√©matiques, physique, chimie, biologie, histoire, litt√©rature, programmation, m√©decine, droit, √©conomie, etc.
4. Si vous ne pouvez pas d√©terminer le th√®me, retournez "general"
5. Retournez SEULEMENT le sujet, sans explications ni texte suppl√©mentaire

Exemples de r√©ponses valides:
- "math√©matiques"
- "histoire ancienne"
- "programmation web"
- "biologie cellulaire"
- "general"`,

        de: `Sie sind Dicttr AI, spezialisiert auf die Analyse von Bildungsinhalten.

Ihre Aufgabe ist es, den bereitgestellten Inhalt zu analysieren und ein geeignetes Thema/Fach zu generieren, das beschreibt, worum es in dem Material geht.

ANWEISUNGEN:
1. Analysieren Sie den Inhalt und extrahieren Sie das Hauptthema
2. Generieren Sie ein pr√§gnantes Thema (maximal 3-5 W√∂rter)
3. Verwenden Sie g√§ngige Bildungskategorien wie: Mathematik, Physik, Chemie, Biologie, Geschichte, Literatur, Programmierung, Medizin, Recht, Wirtschaft usw.
4. Wenn Sie das Thema nicht bestimmen k√∂nnen, geben Sie "general" zur√ºck
5. Geben Sie NUR das Thema zur√ºck, ohne Erkl√§rungen oder zus√§tzlichen Text

G√ºltige Antwortbeispiele:
- "mathematik"
- "alte geschichte"
- "web-programmierung"
- "zellbiologie"
- "general"`,

        it: `Sei Dicttr AI, specializzato nell'analisi di contenuti educativi.

Il tuo compito √® analizzare il contenuto fornito e generare un argomento/tema appropriato che descriva di cosa tratta il materiale.

ISTRUZIONI:
1. Analizza il contenuto ed estrai il tema principale
2. Genera un argomento conciso (massimo 3-5 parole)
3. Usa categorie educative comuni come: matematica, fisica, chimica, biologia, storia, letteratura, programmazione, medicina, diritto, economia, ecc.
4. Se non riesci a determinare il tema, restituisci "general"
5. Restituisci SOLO l'argomento, senza spiegazioni o testo aggiuntivo

Esempi di risposte valide:
- "matematica"
- "storia antica"
- "programmazione web"
- "biologia cellulare"
- "general"`,

        pt: `Voc√™ √© o Dicttr AI, especializado em an√°lise de conte√∫do educacional.

Sua tarefa √© analisar o conte√∫do fornecido e gerar um assunto/tema apropriado que descreva sobre o que o material trata.

INSTRU√á√ïES:
1. Analise o conte√∫do e extraia o tema principal
2. Gere um assunto conciso (m√°ximo 3-5 palavras)
3. Use categorias educacionais comuns como: matem√°tica, f√≠sica, qu√≠mica, biologia, hist√≥ria, literatura, programa√ß√£o, medicina, direito, economia, etc.
4. Se voc√™ n√£o conseguir determinar o tema, retorne "general"
5. Retorne APENAS o assunto, sem explica√ß√µes ou texto adicional

Exemplos de respostas v√°lidas:
- "matem√°tica"
- "hist√≥ria antiga"
- "programa√ß√£o web"
- "biologia celular"
- "general"`,

        ru: `–í—ã - Dicttr AI, —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä—É—é—â–∏–π—Å—è –Ω–∞ –∞–Ω–∞–ª–∏–∑–µ –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞.

–í–∞—à–∞ –∑–∞–¥–∞—á–∞ - –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç –∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –ø–æ–¥—Ö–æ–¥—è—â—É—é —Ç–µ–º—É/–ø—Ä–µ–¥–º–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π –æ–ø–∏—Å—ã–≤–∞–µ—Ç, –æ —á–µ–º –º–∞—Ç–µ—Ä–∏–∞–ª.

–ò–ù–°–¢–†–£–ö–¶–ò–ò:
1. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –∏ –∏–∑–≤–ª–µ–∫–∏—Ç–µ –æ—Å–Ω–æ–≤–Ω—É—é —Ç–µ–º—É
2. –°–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫—Ä–∞—Ç–∫—É—é —Ç–µ–º—É (–º–∞–∫—Å–∏–º—É–º 3-5 —Å–ª–æ–≤)
3. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–µ –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏, —Ç–∞–∫–∏–µ –∫–∞–∫: –º–∞—Ç–µ–º–∞—Ç–∏–∫–∞, —Ñ–∏–∑–∏–∫–∞, —Ö–∏–º–∏—è, –±–∏–æ–ª–æ–≥–∏—è, –∏—Å—Ç–æ—Ä–∏—è, –ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞, –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ, –º–µ–¥–∏—Ü–∏–Ω–∞, –ø—Ä–∞–≤–æ, —ç–∫–æ–Ω–æ–º–∏–∫–∞ –∏ —Ç.–¥.
4. –ï—Å–ª–∏ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–µ–º—É, –≤–µ—Ä–Ω–∏—Ç–µ "general"
5. –í–µ—Ä–Ω–∏—Ç–µ –¢–û–õ–¨–ö–û —Ç–µ–º—É, –±–µ–∑ –æ–±—ä—è—Å–Ω–µ–Ω–∏–π –∏–ª–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–µ–∫—Å—Ç–∞

–ü—Ä–∏–º–µ—Ä—ã –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤:
- "–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞"
- "–¥—Ä–µ–≤–Ω—è—è –∏—Å—Ç–æ—Ä–∏—è"
- "–≤–µ–±-–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ"
- "–∫–ª–µ—Ç–æ—á–Ω–∞—è –±–∏–æ–ª–æ–≥–∏—è"
- "general"`,

        ja: `„ÅÇ„Å™„Åü„ÅØÊïôËÇ≤„Ç≥„É≥„ÉÜ„É≥„ÉÑÂàÜÊûê„Å´ÁâπÂåñ„Åó„ÅüDicttr AI„Åß„Åô„ÄÇ

„ÅÇ„Å™„Åü„ÅÆ„Çø„Çπ„ÇØ„ÅØ„ÄÅÊèê‰æõ„Åï„Çå„Åü„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÇíÂàÜÊûê„Åó„ÄÅ„Åù„ÅÆÊïôÊùê„Åå‰Ωï„Å´„Å§„ÅÑ„Å¶Êâ±„Å£„Å¶„ÅÑ„Çã„Åã„ÇíË™¨Êòé„Åô„ÇãÈÅ©Âàá„Å™‰∏ªÈ°å/„Éà„Éî„ÉÉ„ÇØ„ÇíÁîüÊàê„Åô„Çã„Åì„Å®„Åß„Åô„ÄÇ

ÊåáÁ§∫:
1. „Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÇíÂàÜÊûê„Åó„ÄÅ‰∏ªË¶Å„Å™„Éà„Éî„ÉÉ„ÇØ„ÇíÊäΩÂá∫„Åô„Çã
2. Á∞°ÊΩî„Å™‰∏ªÈ°å„ÇíÁîüÊàê„Åô„ÇãÔºàÊúÄÂ§ß3„Äú5Ë™ûÔºâ
3. Êï∞Â≠¶„ÄÅÁâ©ÁêÜÂ≠¶„ÄÅÂåñÂ≠¶„ÄÅÁîüÁâ©Â≠¶„ÄÅÊ≠¥Âè≤„ÄÅÊñáÂ≠¶„ÄÅ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞„ÄÅÂåªÂ≠¶„ÄÅÊ≥ïÂæã„ÄÅÁµåÊ∏àÂ≠¶„Å™„Å©„ÅÆ‰∏ÄËà¨ÁöÑ„Å™ÊïôËÇ≤„Ç´„ÉÜ„Ç¥„É™„Çí‰ΩøÁî®„Åô„Çã
4. „Éà„Éî„ÉÉ„ÇØ„ÇíÁâπÂÆö„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ"general"„ÇíËøî„Åô
5. Ë™¨Êòé„ÇÑËøΩÂä†„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Å™„Åó„Åß„ÄÅ‰∏ªÈ°å„ÅÆ„Åø„ÇíËøî„Åô

ÊúâÂäπ„Å™ÂõûÁ≠î‰æã:
- "Êï∞Â≠¶"
- "Âè§‰ª£Âè≤"
- "„Ç¶„Çß„Éñ„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞"
- "Á¥∞ËÉûÁîüÁâ©Â≠¶"
- "general"`,

        zh: `ÊÇ®ÊòØ‰∏ìÈó®‰ªé‰∫ãÊïôËÇ≤ÂÜÖÂÆπÂàÜÊûêÁöÑDicttr AI„ÄÇ

ÊÇ®ÁöÑ‰ªªÂä°ÊòØÂàÜÊûêÊèê‰æõÁöÑÂÜÖÂÆπÂπ∂ÁîüÊàê‰∏Ä‰∏™ÈÄÇÂΩìÁöÑ‰∏ªÈ¢ò/È¢òÁõÆÔºåÊèèËø∞ËØ•ÊùêÊñôÊòØÂÖ≥‰∫é‰ªÄ‰πàÁöÑ„ÄÇ

ËØ¥Êòé:
1. ÂàÜÊûêÂÜÖÂÆπÂπ∂ÊèêÂèñ‰∏ªË¶Å‰∏ªÈ¢ò
2. ÁîüÊàêÁÆÄÊ¥ÅÁöÑ‰∏ªÈ¢òÔºàÊúÄÂ§ö3-5‰∏™ËØçÔºâ
3. ‰ΩøÁî®Â∏∏ËßÅÁöÑÊïôËÇ≤Á±ªÂà´ÔºåÂ¶ÇÔºöÊï∞Â≠¶„ÄÅÁâ©ÁêÜ„ÄÅÂåñÂ≠¶„ÄÅÁîüÁâ©„ÄÅÂéÜÂè≤„ÄÅÊñáÂ≠¶„ÄÅÁºñÁ®ã„ÄÅÂåªÂ≠¶„ÄÅÊ≥ïÂæã„ÄÅÁªèÊµéÂ≠¶Á≠â
4. Â¶ÇÊûúÊÇ®Êó†Ê≥ïÁ°ÆÂÆö‰∏ªÈ¢òÔºåËØ∑ËøîÂõû"general"
5. ‰ªÖËøîÂõû‰∏ªÈ¢òÔºåÊó†ÈúÄËß£ÈáäÊàñÈôÑÂä†ÊñáÊú¨

ÊúâÊïàÂõûÁ≠îÁ§∫‰æã:
- "Êï∞Â≠¶"
- "Âè§‰ª£ÂéÜÂè≤"
- "ÁΩëÁªúÁºñÁ®ã"
- "ÁªÜËÉûÁîüÁâ©Â≠¶"
- "general"`,

        ar: `ÿ£ŸÜÿ™ Dicttr AIÿå ŸÖÿ™ÿÆÿµÿµ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ™ÿπŸÑŸäŸÖŸä.

ŸÖŸáŸÖÿ™ŸÉ ŸáŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸÖŸÇÿØŸÖ Ÿàÿ•ŸÜÿ¥ÿßÿ° ŸÖŸàÿ∂Ÿàÿπ/ŸÖÿßÿØÿ© ŸÖŸÜÿßÿ≥ÿ® ŸäÿµŸÅ ŸÖÿß ŸäÿØŸàÿ± ÿ≠ŸàŸÑŸá ÿßŸÑŸÖÿßÿØÿ©.

ÿßŸÑÿ™ÿπŸÑŸäŸÖÿßÿ™:
1. ŸÇŸÖ ÿ®ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑŸÖÿ≠ÿ™ŸàŸâ Ÿàÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä
2. ŸÇŸÖ ÿ®ÿ•ŸÜÿ¥ÿßÿ° ŸÖŸàÿ∂Ÿàÿπ ŸÖŸàÿ¨ÿ≤ (ÿ®ÿ≠ÿØ ÿ£ŸÇÿµŸâ 3-5 ŸÉŸÑŸÖÿßÿ™)
3. ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÅÿ¶ÿßÿ™ ÿ™ÿπŸÑŸäŸÖŸäÿ© ÿ¥ÿßÿ¶ÿπÿ© ŸÖÿ´ŸÑ: ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™ÿå ÿßŸÑŸÅŸäÿ≤Ÿäÿßÿ°ÿå ÿßŸÑŸÉŸäŸÖŸäÿßÿ°ÿå ÿßŸÑÿ£ÿ≠Ÿäÿßÿ°ÿå ÿßŸÑÿ™ÿßÿ±ŸäÿÆÿå ÿßŸÑÿ£ÿØÿ®ÿå ÿßŸÑÿ®ÿ±ŸÖÿ¨ÿ©ÿå ÿßŸÑÿ∑ÿ®ÿå ÿßŸÑŸÇÿßŸÜŸàŸÜÿå ÿßŸÑÿßŸÇÿ™ÿµÿßÿØÿå ÿ•ŸÑÿÆ.
4. ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ÿ™ŸÖŸÉŸÜ ŸÖŸÜ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÖŸàÿ∂Ÿàÿπÿå ŸÇŸÖ ÿ®ÿ•ÿ±ÿ¨ÿßÿπ "general"
5. ŸÇŸÖ ÿ®ÿ•ÿ±ÿ¨ÿßÿπ ÿßŸÑŸÖŸàÿ∂Ÿàÿπ ŸÅŸÇÿ∑ÿå ÿØŸàŸÜ ÿ™ŸÅÿ≥Ÿäÿ±ÿßÿ™ ÿ£Ÿà ŸÜÿµ ÿ•ÿ∂ÿßŸÅŸä

ÿ£ŸÖÿ´ŸÑÿ© ÿπŸÑŸâ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿßŸÑÿµÿßŸÑÿ≠ÿ©:
- "ÿßŸÑÿ±Ÿäÿßÿ∂Ÿäÿßÿ™"
- "ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÇÿØŸäŸÖ"
- "ÿ®ÿ±ŸÖÿ¨ÿ© ÿßŸÑŸàŸäÿ®"
- "ÿ®ŸäŸàŸÑŸàÿ¨Ÿäÿß ÿßŸÑÿÆŸÑŸäÿ©"
- "general"`
      };

      // Usar el prompt del idioma especificado o fallback a espa√±ol
      const systemPrompt = subjectPrompts[translationLanguage] || subjectPrompts.es;

      const response = await deepseek.chat([
        {
          role: "system",
          content: systemPrompt
        },
        {
          role: "user",
          content: `Analiza este contenido y genera un asunto apropiado:\n\n${truncatedText}`
        }
      ], DEEPSEEK_MODELS.CHAT);

      const generatedSubject = response.choices[0].message.content.trim().toLowerCase();

      console.log('‚úÖ Asunto generado:', generatedSubject);
      return generatedSubject;

    } catch (error) {
      console.error('‚ùå Error generando asunto con IA:', error.message);
      console.log('‚ö†Ô∏è  Devolviendo null (sin asunto)');
      return null; // Sin asunto en lugar de "general"
    }
  }

  // Extraer texto de contenido enhanced estructurado
  extractTextFromEnhancedContent(enhancedContent) {
    if (!enhancedContent) return '';

    let text = '';

    // Si tiene t√≠tulo, a√±adirlo
    if (enhancedContent.title) {
      text += enhancedContent.title + '\n\n';
    }

    // Extraer texto de las secciones
    if (enhancedContent.sections && Array.isArray(enhancedContent.sections)) {
      enhancedContent.sections.forEach(section => {
        if (section.content) {
          text += section.content + '\n';
        }
        if (section.term && section.definition) {
          text += `${section.term}: ${section.definition}\n`;
        }
        if (section.items && Array.isArray(section.items)) {
          text += section.items.join('\n') + '\n';
        }
      });
    }

    // Extraer conceptos clave
    if (enhancedContent.key_concepts && Array.isArray(enhancedContent.key_concepts)) {
      text += 'Conceptos clave: ' + enhancedContent.key_concepts.join(', ') + '\n';
    }

    // Extraer resumen
    if (enhancedContent.summary) {
      text += enhancedContent.summary + '\n';
    }

    return text.trim() || JSON.stringify(enhancedContent);
  }
}

module.exports = new TranscriptionService();
